---
title: 基于共享内存的通用内存分配器
date: 2020-02-07
categories: develop 
author: yawei.zhang 
---

### ..1. 目录  


### 通用的内存分配器
#### 数据结构和概述  
```C++
    /*  perfect binary true
    *                   0        -----------   : reserve
    *	                1        -----------   :  root 
    *
    *          2                 3
    *
    *     4        5         6        7
    *
    *   8   9   10   11   12   13  14   15
    *
    * ----------------------------------------
    *
    *   0   1   2    3    4    5   6     7     : memory buff
    *
    */
```
![buddy_system](/images/buddy_system.gif)
伙伴算法是一个特殊的分离适配的内存管理器  
* 被管理的内存必须是2的幂次方对齐 通过上述结构可以观察到  
* 分配的单位必须是2的幂次对齐  
* 回收时候回对伙伴空闲块进行合并   

显而易见, 伙伴算法有明显的缺点和优点  
缺点:  
* 极大的内存浪费, 因为2的幂次对齐分配, 比如我们需要power(2, 12)+1 的内存 实际上就会分配power(2,13)的内存,  内部碎片比例为 (power(2, 12)+1)/power(2,13), 有效负荷只有0.5左右. 

* 外部碎片, 并不是所有的相邻空闲块都能合并, 必须满足伙伴的条件,  因此相比只要是相邻空闲内存就会合并的算法而言, 会带来更多的内存碎片   

* 分配复杂度  
  最好为O(1), 即最大空间的分配, 最坏为叶子节点 LGN, 从root查找到叶子节点, 然后向上修改每个节点的当前的最大可分配大小     
  

* 释放复杂度
  最好为O(1), 即叶子空间的分配, (查找某个地址所在的层级, 从叶子节点)  
  合并复杂度, 向上合并, 最好为O(1) 无法合并, 最坏为LGN, 全部合并.   

如果结合SLAB分配器看.
* 来自SLAB分配器的申请: 粒度都是2的幂次, 完全避免了内部碎片  
* 来自SLAB分配器的申请: 分配的粒度都是同一层级, 避免了外部碎片  

通用的内存管理器中, 伙伴系统是批发商, slab是零售商这个比喻是很形象的.  



#### 数据结构的定义:  

同linux系统的方式类似, 我们按照页框为单位来管理内存, 页框的大小大于等于系统的页框大小, 可结合slab分配器进行调整.  
根据要管理的内存大小和页框大小, 我们可以算出总得叶子数量,  而在这棵树上, 节点总数为2N(2倍叶子节点)   

因此数据结构的定义为如下方式:
```
共享内存管理头部: 所有叶子节点 : 被管理的内存
```

每个节点用1个字节来记录, 内容为该节点的所对应的空间大小, (这里记录的不是大小, 而是大小的幂, 所以可以用一个字节来存储)   
该节点对应的空间起始地址这位该节点在该层中的offset* power(2, order), 


##### 初始化  
所有节点的初始化为为该节点的空间大小.  
例如index1 对应的则是被管理的所有空间  
然后每层递减1  
到叶子节点则为2^0次幂大小, 即一个页框单位.  


##### 分配  
如果分配参数是字节数, 则需要先按照页框向上取整   
如果分配的参数是页框数量, 则需要按照2的幂次取整, 可以用bit search指令获取2的幂数(这个取法是向下取整 所以取完后要进行一次向上取整)   
如果分配的是order  
则检查root节点保存的order是否满足需求, 不满足这代表没有足够大的空间  
如果满足需求则逐层查找, 直到到达对应的order层级, 然后修改该节点的可分配空间为0, 然后逐层向上修改分配能力  

tips:
 这里定义0为已分配, 而不是power(2,0)个空间大小,  因此在这里节点对应空间大小计算是power(2, (order ability)-1)   -1后才是power(2, order) .   
 这样可以保证这棵树中从叶子节点向上查找时候的可以简单的while循环时候少一次边界判定, 计算方便   

分配时候永远选择刚好满足需求的路径, 可以减少切分大块, 其次优先左子树,  减少外部碎片的产生以及提高cache命中.  


 ##### 释放  
 通过地址计算页框编号, 然后加上N (树的大小是2N, N为所有非叶子节点的节点总数) 得到叶子节点的索引.  
 从叶子节点用IDX /2 不断的向上查找, 直到找到节点被标记为0的层级,  修改该节点为该层级对应的空间大小, 然后逐层向上修改每层的新的空间分配能力, 如果左右节点的空间大小为该层级的大小(都空闲)则合并,(每个上层节点的能力均是节点对应的空间大小)   


### SLAB内存分配器   
面向终端用户的内存分配器, 或者说BUDDY SYSTEM管批发, 这里管零售.    
好的SLAB内存分配器并没有那么容易编写和验证,  因此我们选择了移植一个dlmalloc, 代码简单, 移植方便, 性能也是经过linux系统的验证, 虽然更现代的内存分配器更优秀, 但是用在项目中还是优先选择一个满足需求但是所有代码看的明白的库更容易进行分析和定制.    

有了buddy system之后, 移植所有可以基于mmap或者brk批量分配的内存分配器都会变得容易, 常见的现在linux系统使用的ptmalloc, 以及常用的TCMALLOC或者jemalloc都是基于dlmalloc的思想进行了更优的实现, 体现在更好的内存利用率, cpu cache更友好的分配策略, 多线程下更少的竞争等.   

dlmalloc是一个典型的分离存储的分配器, 并充分使用了'池'来减少频繁的内存申请和返还.   

对于小内存 小于256的, 很类似我上篇文章讲的对象池分配器, 或者说我们的对象池分配器参照了dlmalloc小内存的分配算法.   

dlmalloc定义了最小的分配粒度为8字节, 这样在保存chunk大小的字段中可以多出来3个位作为bit标记   
然后每8个字节递增, 直到248字节. 
[bin idx] 8 8 8 8 8 8 8 8 8 
[bin idx] 16 16 16 16 16 16   
[bin idx] 24 24 24 24 24 24   
...
[bin idx] 248 248 248 248 248 248  



#### 小内存分配   
首先检查对应bin idx是否有空闲chunk 有这分配并返回   
其次检查更高bin idx中是否有空闲的chunk, 有则切割, 并把剩余大小组合成一个新chunk记录为切割剩余chunk(如果过小则直接丢给用户)  
其次检查大内存的bin里面是否有内存 有则切割 同上  
其次检查上次剩余切割的chunk是否满足需要 如果满足则进一步切割 同上  
其次检查最新从上级分配器(buddy system, 或者对应系统函数mmap brk)得到的大块chunk的剩余是否满足 满足就切割 (brk表现为扩展top)   
其次则申请一个新的大块chunk进行切割   




#### 大内存分配  
大内存的bin idx递增则为2的幂次的半高为区分  例如:  

[256~384)  
[384~512)
[512~768)
...
[4096~6144)
...
[768k~1m)  


首先查找对应的bin idx是否存在空闲
  如果有空闲着按照一个简版的线段树查找最优大小的内存块
  如果找到这返还  
其次检查更高bin idx中是否存在空闲, 如果有则拿最小的一个chunk进行切分, 切分后的数据块保存记录到(最后一层切割剩余的chunk)中   

其次检查剩余chunk的大小是否满足, 满足则进一步切割  

其次检查最近一次向上层管理器申请的内存chunk是否满足需求, 满足则切分 同上    

其次选择申请新的大块chunk


#### 内存返还  
返还时会根据标志检查是否存在前一个空闲块 如果存在则合并.  
合并后的内存是否满足回收给上层分配器, 满足这返还 (检查是否是top 剩余切割 这两个保留, 是否满足正好是向上层申请的边界和大小, 如果是brk则是是否是top下超过某阈值大小的空闲块)    
不满足则插入到对应的bin空闲块中.   


#### 超大内存  
对于大于该阈值内存直接走上层分配器  比如mmap或者brk  




#### tips     
dlmalloc总是进行最大化的空闲块合并 减少外部碎片,  通过bin分箱最小化内部碎片的产生和大块内存分配时的树的高度.  
绝大部分时候小内存都能做到常数级的分配, 对于大内存的分配因为bin分箱有效的控制bitwish树的高度  


