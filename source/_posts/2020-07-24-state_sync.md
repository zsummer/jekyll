---
title: 多人游戏中的同步机制综述 
date: 2020-07-24
categories: develop 
author: yawei.zhang 
---

## 前言    
本文中所有内容默认都基于逻辑描述, 逻辑状态,逻辑处理的逻辑游戏世界,  纯本地表现类, 总是通过逻辑世界单向导出的渲染计算等, 均不在本篇文章讨论范畴.  


## 同步问题的产生和基本策略机制  

**在多人游戏或者基于CS网络模型的游戏中, 玩家所在的游戏世界并非全由本地生成和修改, 必须不断从服务器或者其他玩家获得最新的信息来完成游戏世界的共享体验, 在多人实时交互的游戏中,  相当于每个人都维护一个'完整世界'的副本, 并保证每个人维护的副本之间一致性和实时性, 不同游戏对副本的规模复杂度以及对一致性和实时性的要求不同, 在不同的历史时期的演进下则产生了多种同步方案来实现这一要求.**   


在所有的同步方案中, 有两种最基础也最常见的同步机制, 即状态同步和帧同步, 其基本机制和区别为:  

* **状态同步: 直接描述则为 通过同步游戏中的各种状态来保证游戏世界副本的一致性, 基本流程如下:**   
  * 服务器维护权威完整副本  客户端维护本地副本 <font color=#ccc> (可以只维护部分副本) </font>   
  * 客户端上行请求到服务器 服务器进行完整的逻辑演算 并将发生改变的状态下行给客户端   
  * <font color=#ccc>客户端基于本地副本进行预演和状态预刷新 </font>  
  * 客户端用来自服务器的状态数据刷新本地副本, 对齐服务器副本   
    * <font color=#ccc>客户端如果有因预演导致的数据不对齐需要通过强同步/回滚/和解等机制达成最终对齐</font>   
      * <font color=#ccc>快照类同步方式总是全量对齐</font>   

  
* **帧同步: 直接描述其基本原理则为: 通过一致的初始副本和一致的输入事件与一致的逻辑处理, 来保证游戏世界副本的一致性**  
  * 帧同步的变种和演化分支比较多
    * 是否锁步分为帧锁定同步和按帧同步两种模式   
    * 网络拓扑是对等还是CS模式, 鼻祖DOOM1最开始为P2P对等网络的锁步同步, 后来改为CS模式的锁步同步  
    * 是否存在权威节点, 分为主机模式和非主机模式  
  
  * 原始的对等网络锁步同步流程:  
    * 客户端初始一致的游戏逻辑环境  
    * 客户端定义关键帧的间隔 并记录每个其他玩家的的帧信息    
    * 广播按键信息并缓存 
    * 所有客户端如果均进入新的关键帧则执行所有指令并清空缓存 否则进入等待  
    * 继续进行    
  
  * 当下流行的帧同步模式为独立服务器转发的非锁步帧同步大致流程如下:     
    * 服务器:  
      * 初始化帧编号, 定义关键帧   
        * 每帧广播帧号并收集所有来自客户端的上行指令   
        * 广播关键帧时携带所有已搜集到的上行指令并清空指令缓存 <font color=#fca> 这里不会发生依赖其他客户端的等待 </font>    
    * 客户端:  
      * 判断当前帧是否为关键帧, 如果不是则不处理指令      
        * 如果是关键帧, 则检查是否收到该关键帧的更新, 如果没有则等待  
          * 执行指令逻辑   
      * 执行当前帧的逻辑   


这里只是简单描述其概念和基本策略, 不做细节阐述;  
需要注意的是, **这两者并不冲突并能相互借鉴补充**, 在上述的简单描述中通过灰色部分注明了一部分常见的相互补充方式,  通常在具体的实践中会对同步策略进行细节的定制以及相互补充来达到相对项目最好的同步效果, 典型的是DS服务器和存在完整逻辑演算的帧同步服务器.      




## 网络同步模型的形式化描述    

在锁步同步中, 逻辑帧一般称为Tick, 而渲染帧被称为Frame,  在确定性的帧同步中不会引入物理时间, 其时间的尺度即是逻辑帧的步.   
在确定性锁步帧同步中, 其逻辑处理是一个逻辑帧一个逻辑帧执行的,  可以抽象为以下公式:   

$$
S_k=\begin{cases}
g(P, C), \qquad if K > 0 \\\\
t(S_{k-1}, C, I_k),  \quad if K \geq 0
\end{cases}
$$


I是游戏状态变化的根本原因的集合 往往是各个玩家(按键)操作  
S是游戏状态的集合 由众多状态子集组成  

该公式的描述: 
* 游戏在第0个逻辑帧时 根据玩家信息P和游戏配置C 进行初始化运算g 得出初始化状态集合$S_0$    
* 游戏在第k个逻辑帧时 根据前一个状态集合$S_{k-1}$和游戏配置C  根据第k帧收到的外部变化原因集合$I_k$ 进行逻辑t运算 得出第k个逻辑帧新的游戏状态集合$S_k$   
  

游戏状态的集合有关键的两个子集定义:   


$$
S  \begin{cases}
O = \{ o \in S  \quad|\quad \text {o is an important state that can be observed by the player} \}  \\\\
M = \{ m \in S  \quad|\quad \text {m is an intermediate state to infer the final state} \}  
\end{cases}
$$
<p align = "left">  


$$
S \begin{cases}
O = \{ o \in S  \quad|\quad \text {o 是一些能被玩家所明显观察到的对象的状态集合} \}     \qquad \quad \\\\
M = \{ m \in S  \quad|\quad \text  {m 一些可用于推导最终状态的中间状态集合} \}  
\end{cases}
$$


在网络同步时，称从客户端发出信息进行网络传输的过程为上行，称客户端经过网络传输收到信息的过程为下行:   

**一般锁步同步的本质是: 上下行都仅包含游戏外部变化原因集合Ik**   
**一般状态同步的本质是: 下行仅包含游戏运算得出的结果状态集合S_k（更精确地说是状态子集O_k），上行包含Ik和/或状态子集M_k**  
   


## 游戏中的状态一致性问题   
### 关键状态   
### 可容忍偏差状态  
### 可推导恢复状态   
### 可丢弃状态   

## 游戏中的实时性问题   
### 网络传送中的延迟和相关延迟   
### 运算延迟  
### 渲染延迟   
### 流程延迟  



## 综合实践案例   

