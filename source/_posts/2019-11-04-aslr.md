---
title: linux内存布局和ASLR  
date: 2019-11-04
categories: develop 
author: yawei.zhang 
---
### 内存布局    
###### 基本布局  
内核地址空间范围  [0XFFFF 0000 0000 0000, 0XFFFF FFFF FFFF FFFF]
不规范地址空间    (0XFFFF 0000 0000 0000, 0X0000 FFFF FFFF FFFF)
用户地址空间      [0X0000 FFFF FFFF FFFF, 0X0000 0000 0000 0000]

备注: 用户空间范围对应为0~TASK_SIZE = 2^VA_BITS
1. 用户地址空间默认最大宽度是48 如上  
2. 内核地址空间和用户地址空间宽度相同  
3. 不同的页长默认有不同的宽度, 例如4KB页长默认是39位   16:47, 64:42等, 可直接选择48位.  
4. 开启LVA支持并且页长64可以支持到最大宽度52   

###### 内核布局   
###### 用户空间布局   
* TASK_SIZE
* 栈空间,  向下增长  具体位置为(STACK_TOP - 随机值), STACK_TOP对应TASK_SIZE  
  * 栈的位置不能超过STACK_TOP的5/6,并且保证128M的栈空间  对齐到页.   
  
* 内存映射区域(mmap) 老版本 TASK_UNMAAPPED_BASE+随机值 向上增长   
* 内存映射区域(mmap) 新版本 STACK_TOP - 栈最大长度 - 间隙 - 随机值  向下增长  x86 2.6.7版本后   
  * 新老版本的差别在于 新版本 堆和内存映射区域向同一个空间增长, 栈有最大长度限制 在32位下通过压缩栈的空间大小可以让堆和内存映射区域获得最大的使用空间.   



* 堆空间(Heap)  brk/sbrk分配

* BSS段(Block Started by Symbol) 未初始化数据段或者初始化为0 的全局变量和静态局部变量    * loader加载程序时, 会将BSS段分配的内存清零, 在目标文件中并不占用空间(目标没有BSS段 只有记录名称和大小).  
  
* 数据段(Data)  已初始化并且非0的全局变量和静态局部变量 
  * 例如int a[10000] = {1,2,3, ...}; 与 int a[10000];
  * 前者在程序中有完整的数据存储, 而后者指标记了使用的大小, 对于目标文件来说会节省非常多的存储空间.   
  
* 代码段(Text)  存放机器指令  只读  
  * 存放
* 保留区
* 0

###### 多线程 
非主线程的栈是mmap出来的 
```

mem = mmap (NULL, size, prot,
            MAP_PRIVATE | MAP_ANONYMOUS | MAP_STACK, -1, 0);
```


### ELF文件装载过程  

### Address space layout randomization 地址空间布局随机化  
  可以防范return-to-libc 这种攻击





##### ASLR在linux中的三个等级以及配置和禁用方法    
* 系统全局配置
```
/proc/sys/kernel/randomize_va_space
0 = Disabled
1 = Conservative Randomization
2 = Full Randomization
```  

1. 关闭  
2. 保守随机化: 共享库 栈 mmap  vdso随机化   
3. 完全随机化:  包括brk分配的内存   
    2.1 代码段和数据段的随机化需要PIE位置无关可执行程序的支持  编译链接时添加 -fpie -pie   

> brk和mmap的分配由glibc确定 默认规则是小于M_MMAP_THRESHOLD宏走brk  但是新系统的算法可能会让大于这个参数的临时分配也走brk   

* 修改/关闭系统配置
```
# sysctl -w kernel.randomize_va_space=0
# echo 0 > /proc/sys/kernel/randomize_va_space
```

* 进程个性化设置: 进程描述符的成员personality设置 ADDR_NO_RANDOMIZE     
  * setarch $(uname -m) -R [--addr-no-randomize] [target exe]
  * 例如 ldd ./benchmark_fast 在aslr环境下会看到每次so的内存位置都在变化   
    * setarch $(uname -m) -R ldd ./benchmark_fast 这样去查看则是固定不变的  



ldd命令  



代码段/数据段的随机化  
gcc 编译时


PIE 位置无关可执行程序  
PIC 

KASLR  内核地址空间布局随机化  

### SDM框架对系统发展生命周期的过程描述  
SDM(软件开发方法)框架是在SDLC在软件开发早起
* (SDM框架)软件开发过程有以下基本的核心活动内容
  * 需求分析 (Requirements analysis)  
  * 领域设计 (Software design)  
  * 系统设计 (Software engineering)  
  * 编码开发 (Software construction)  
  * 功能验证 (Software testing)  
  * 错误修正 (Debugging)    
  * 部署交付 (Software deployment)  
  * 维护 (Software maintenance)   
<!-- more --> 
根据所面临的现实问题以及所在环境的不同, 这些核心活动内容会在结构关系以及流程顺序上有相应的调整或者取舍 形成不同的规范/模型/框架等.   

例如:  
* 线性过程的瀑布式开发模型 SDLC:专注于完整正确的计划   
* 快速迭代的敏捷开发   : 持续交付来响应频繁变更的计划(快速试错) 
* 加强发布协调的DevOps   

同设计模式一样, 这些模型提炼自对现实问题的具体解决过程, 在实际应用中并不需要一定去拘泥某个规范.  
实际上, 在一个具备一定规模的项目中, 往往同时存在多种不同的开发方式共同组成适合该项目的开发过程,  这种方式也称之为'混合模型',  在混合模型中,  允许一个项目沿着最有效的路径去组织属于自己的活动内容,  合适现实问题解决模型才是最恰当的.  

