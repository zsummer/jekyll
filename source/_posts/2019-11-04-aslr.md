---
title: linux内存布局和ASLR  
date: 2019-11-04
categories: develop 
author: yawei.zhang 
---
### 内存布局    
###### 基本布局  
内核地址空间范围  [0XFFFF 0000 0000 0000, 0XFFFF FFFF FFFF FFFF]
不规范地址空间    (0XFFFF 0000 0000 0000, 0X0000 FFFF FFFF FFFF)
用户地址空间      [0X0000 FFFF FFFF FFFF, 0X0000 0000 0000 0000]

备注: 用户空间范围对应为0~TASK_SIZE = 2^VA_BITS
1. 用户地址空间默认最大宽度是48 如上  
2. 内核地址空间和用户地址空间宽度相同  
3. 不同的页长默认有不同的宽度, 例如4KB页长默认是39位   16:47, 64:42等, 可直接选择48位.  
4. 开启LVA支持并且页长64可以支持到最大宽度52   
5. 通过getconf PAGE_SIZE 可以查看系统的页大小  
6. 通过/proc/$pid/maps或者pmap可以查看一个进程的实际内存布局 
7. mprotect 可以修改内存页权限   
8. madvise 可以修改建议内存使用的方式  
9. 老的LinuxThreads (管理线程机制) 设计中线程栈的位置在 HEAP之下 的高位 导致无法可信的设置heap大小  
10. 新的NPTL解决了老的线程机制中的管理单点问题 信号问题 内存布局问题等 顺便实现了PTHREAD_PROCESS_SHARED 
11. pthread_attr_setstackaddr可指定线程栈的地址(mmap)   
12. pthread的创建和销毁 
    1.  创建   
        1. 使用用户提供的stack创建线程并加入__stack_user 
        2. nptl 先尝试获取stack_cache中tid为0大小合适的空闲stack, 如果失败则从mmap分配新的stack, 然后加入stack_used  
        3. tid list等信息存储在stack内存的高地址端的头部  
    2.  start_thread执行完用户函数后会进行数据回收和清理(但无法销毁自身)   
        1. 如果该线程非detach 则等待join  (没有join则会一直保留)  
        2. 如果该线程被detach 则执行__free_tcb   
            1. 如果是用户分配的stack 从stack_user链表中移除并清理tls 线程局部存储  
            2. 如果是自动分配的stack 从stack_used链表中移除, 然后加入stack_cache中, 清理tls线程局部存储(此时tid不为0)   
            3. 检查当前stack_cache的总大小, 超过阈值则遍历一次stack_cache并释放掉(tid为0)空闲的stack, 如果小于阈值则提前break该次遍历   
    3. 内核在该线程结束后 会对该线程的tid清零(创建线程时CLONE_CHILD_CLEARTID参数会让内存清除某标记内存), 此后该资源可以安全销毁.        
13. brk和mmap的分配由glibc确定 默认规则是小于M_MMAP_THRESHOLD宏走brk  但是新系统的算法可能会让大于这个参数的临时分配也走brk   
<!-- more --> 
###### 内核布局   
###### 用户空间布局   

| - 用户空间布局 - |
|- |
| 0x0 |
| 保留区 |
| 代码段(PLT代码表部分) |
| 代码段 |
| 数据段(GOT) 只读|
| 数据段(.got.plt) 惰性加载机制|
| 数据段(Data) |
| BSS段 |
| 堆空间(Heap) |
| ↓  |
| ↑  |
| 内存映射区域(mmap) |
| 栈空间(进程栈) |
| TASK_SIZE |





###### 多线程 
非主线程的栈是mmap出来的 
```

mem = mmap (NULL, size, prot,
            MAP_PRIVATE | MAP_ANONYMOUS | MAP_STACK, -1, 0);
```


### ELF文件装载过程  

### Address space layout randomization 地址空间布局随机化  
  可以防范return-to-libc 这种攻击





##### ASLR在linux中的三个等级以及配置和禁用方法    
* 系统全局配置
```
/proc/sys/kernel/randomize_va_space
0 = Disabled
1 = Conservative Randomization
2 = Full Randomization
```  

1. 关闭  
2. 保守随机化: 共享库 栈 mmap  vdso随机化   
3. 完全随机化:  包括brk分配的内存   
    2.1 代码段和数据段的随机化需要PIE位置无关可执行程序的支持  编译链接时添加 -fpie -pie   



* 修改/关闭系统配置  
```
# sysctl -w kernel.randomize_va_space=0
# echo 0 > /proc/sys/kernel/randomize_va_space
```

* 进程个性化设置: 进程描述符的成员personality设置 ADDR_NO_RANDOMIZE     
  * setarch $(uname -m) -R [--addr-no-randomize] [target exe]
  * 例如 ldd ./benchmark_fast 在aslr环境下会看到每次so的内存位置都在变化   
    * setarch $(uname -m) -R ldd ./benchmark_fast 这样去查看则是固定不变的  



ldd命令  



* 代码段/数据段的随机化 通过PIE(编译位置无关可执行文件)PIC(position-independent code位置无关代码)控制 
  * gcc 编译程序时-fpie 链接时-pie  
  * gcc 编译动态库时 -fpic

* 内核

KASLR  内核地址空间布局随机化  



##### 随机化过程 X86    


栈的随机化过程    

栈的起始地址计算为:  
TASK_SIZE - random()&(0x3ffff000)  =[TASK_SIZE, TASK_SIZE - 0x3ffff000‬]   

```C++
/* 1GB for 64bit, 8MB for 32bit */
#define __STACK_RND_MASK(is32bit) ((is32bit) ? 0x7ff : 0x3fffff)
#define STACK_RND_MASK __STACK_RND_MASK(mmap_is_ia32())

static unsigned long stack_maxrandom_size(unsigned long task_size)
{
	unsigned long max = 0;
	if (current->flags & PF_RANDOMIZE) {
		max = (-1UL) & __STACK_RND_MASK(task_size == task_size_32bit());
		max <<= PAGE_SHIFT;
	}

	return max;
}
```



mmap的起始随机为   
STACK_TOP - 栈最大长度  - 间隙 -  随机值  

随机值范围为0~0xFF FFFF FFFF   

```C++

#define TASK_SIZE_MAX     ((1UL << 47) - PAGE_SIZE) //0x7FFFFFFFF000
#define TASK_SIZE     TASK_SIZE_MAX

#define STACK_TOP          TASK_SIZE
#define STACK_TOP_MAX          TASK_SIZE_MAX


void arch_pick_mmap_layout(struct mm_struct *mm, struct rlimit *rlim_stack)
{

	mm->get_unmapped_area = arch_get_unmapped_area_topdown;

	arch_pick_mmap_base(&mm->mmap_base, &mm->mmap_legacy_base,
			arch_rnd(mmap64_rnd_bits), task_size_64bit(0),
			rlim_stack);  //proc/sys/vm/mmap_rnd_bits  default=28

}


static unsigned long arch_rnd(unsigned int rndbits)
{
	if (!(current->flags & PF_RANDOMIZE))
		return 0;
	return (get_random_long() & ((1UL << rndbits) - 1)) << PAGE_SHIFT;  //0x3ffff << 12   0xFF FFFF FFFF
}

/*
 * 新布局直接调用*base = mmap_base(random_factor, task_size, rlim_stack);  
 */
static void arch_pick_mmap_base(unsigned long *base, unsigned long *legacy_base,
		unsigned long random_factor, unsigned long task_size,
		struct rlimit *rlim_stack)
{
	*legacy_base = mmap_legacy_base(random_factor, task_size);
	if (mmap_is_legacy())
		*base = *legacy_base;
	else
		*base = mmap_base(random_factor, task_size, rlim_stack);
}

//这是是随机值的上下限保护 栈至少要有128M 
static unsigned long mmap_base(unsigned long rnd, unsigned long task_size,
			       struct rlimit *rlim_stack)
{
	unsigned long gap = rlim_stack->rlim_cur;
	unsigned long pad = stack_maxrandom_size(task_size) + stack_guard_gap;
	unsigned long gap_min, gap_max;

	/* Values close to RLIM_INFINITY can overflow. */
	if (gap + pad > gap)
		gap += pad;

	/*
	 * Top of mmap area (just below the process stack).
	 * Leave an at least ~128 MB hole with possible stack randomization.
	 */
	gap_min = SIZE_128M;
	gap_max = (task_size / 6) * 5;

	if (gap < gap_min)
		gap = gap_min;
	else if (gap > gap_max)
		gap = gap_max;

	return PAGE_ALIGN(task_size - gap - rnd);
}

static unsigned long stack_maxrandom_size(unsigned long task_size)
{
	unsigned long max = 0;
	if (current->flags & PF_RANDOMIZE) {
		max = (-1UL) & __STACK_RND_MASK(task_size == task_size_32bit());
		max <<= PAGE_SHIFT;
	}

	return max;
}

```


brk随机  
```C++
unsigned long arch_randomize_brk(struct mm_struct *mm)
{
	return randomize_page(mm->brk, 0x02000000);
}
```


代码段数据段等整体随机  
```C++
if (interpreter) {
				load_bias = ELF_ET_DYN_BASE;
				if (current->flags & PF_RANDOMIZE)
					load_bias += arch_mmap_rnd();
				elf_flags |= MAP_FIXED;
			} else
				load_bias = 0;
```

```C++  
	loc->elf_ex.e_entry += load_bias;
	elf_bss += load_bias;
	elf_brk += load_bias;
	start_code += load_bias;
	end_code += load_bias;
	start_data += load_bias;
	end_data += load_bias;
```


### 脚注  



###### pmap x86一个带共享内存的进程.  00007f1-00007f2之间是64G大小的空间
```
pmap 22621

22621:   ../../???/bin/???  --conf-file=../cfg.xml  
0000000000400000  32460K r-x--  /data/home/???/bin/???
00000000025b3000    724K rw---  /data/home/???/bin/???
0000000002668000  49260K rw---    [ anon ]
0000000006835000  25172K rw---    [ anon ]
00000000080ca000 284456K rw---    [ anon ]
00000000404e9000    128K rw---    [ anon ]
0000000040fe3000    128K rw---    [ anon ]
00007f1000000000 2511808K rw-s-    [ shmid=0x39020085 ]
00007f213db99000      4K -----    [ anon ]
00007f213db9a000   8192K rw---    [ anon ]
00007f213e39a000   7336K r--s-  /dev/shm/???/???.nav
00007f213eac4000   8588K r--s-  /dev/shm/???/???.nav
00007f213f327000   7336K r--s-  /dev/shm/???/???.nav
00007f213fa51000   2052K rw-s-    [ shmid=0x39018084 ]
00007f213fc52000  40964K rw-s-    [ shmid=0x38f40068 ]
00007f2142453000  40964K rw-s-    [ shmid=0x38dd003a ]
00007f2144c54000  40964K rw-s-    [ shmid=0x38db0036 ]
00007f2147455000  40964K rw-s-    [ shmid=0x38d7802f ]
00007f2149c56000  40964K rw-s-    [ shmid=0x38d40028 ]
00007f214c457000  40964K rw-s-    [ shmid=0x38d10022 ]
00007f214ec58000  40964K rw-s-    [ shmid=0x38cf801f ]
00007f2151459000  40964K rw-s-    [ shmid=0x38cb0016 ]
00007f2153c5a000  40964K rw-s-    [ shmid=0x38ca0014 ]
00007f215645b000  40964K rw-s-    [ shmid=0x38c90012 ]
00007f2158c5c000  40964K rw-s-    [ shmid=0x38c7800f ]
00007f215b45d000   1024K rw-s-    [ shmid=0x50806c ]
00007f215b55d000   1576K r-x--  /lib64/libc-2.12.so
00007f215b6e7000   2048K -----  /lib64/libc-2.12.so
00007f215b8e7000     16K r----  /lib64/libc-2.12.so
00007f215b8eb000      4K rw---  /lib64/libc-2.12.so
00007f215b8ec000     20K rw---    [ anon ]
00007f215b8f1000    524K r-x--  /lib64/libm-2.12.so
00007f215b974000   2044K -----  /lib64/libm-2.12.so
00007f215bb73000      4K r----  /lib64/libm-2.12.so
00007f215bb74000      4K rw---  /lib64/libm-2.12.so
00007f215bb75000      8K r-x--  /lib64/libdl-2.12.so
00007f215bb77000   2048K -----  /lib64/libdl-2.12.so
00007f215bd77000      4K r----  /lib64/libdl-2.12.so
00007f215bd78000      4K rw---  /lib64/libdl-2.12.so
00007f215bd79000     92K r-x--  /lib64/libpthread-2.12.so
00007f215bd90000   2048K -----  /lib64/libpthread-2.12.so
00007f215bf90000      4K r----  /lib64/libpthread-2.12.so
00007f215bf91000      4K rw---  /lib64/libpthread-2.12.so
00007f215bf92000     16K rw---    [ anon ]
00007f215bf96000      8K r-x--  /lib64/libutil-2.12.so
00007f215bf98000   2044K -----  /lib64/libutil-2.12.so
00007f215c197000      4K r----  /lib64/libutil-2.12.so
00007f215c198000      4K rw---  /lib64/libutil-2.12.so
00007f215c199000     28K r-x--  /lib64/librt-2.12.so
00007f215c1a0000   2044K -----  /lib64/librt-2.12.so
00007f215c39f000      4K r----  /lib64/librt-2.12.so
00007f215c3a0000      4K rw---  /lib64/librt-2.12.so
00007f215c3a1000    128K r-x--  /lib64/ld-2.12.so
00007f215c43c000      4K rw---    [ anon ]
00007f215c43d000    208K r--s-  /dev/shm/???/???.nav
00007f215c471000    188K rw-s-    [ shmid=0x38c6800d ]
00007f215c4a0000     20K rw---    [ anon ]
00007f215c4a5000     16K rw---    [ anon ]
00007f215c4a9000      4K r--s-  /dev/shm/???/???.nav
00007f215c4aa000      4K r--s-  /dev/shm/???/???.nav
00007f215c4ab000     20K rw---    [ anon ]
00007f215c4b0000      8K rw---    [ anon ]
00007f215c4b2000     20K rw---    [ anon ]
00007f215c4b7000     12K r-x--  /lib64/lib???rity.so.1.0.19
00007f215c4ba000   1024K -----  /lib64/lib???rity.so.1.0.19
00007f215c5ba000      4K rw---  /lib64/lib???ity.so.1.0.19
00007f215c5bb000     16K rw---    [ anon ]
00007f215c5bf000      4K rw---    [ anon ]
00007f215c5c0000      4K r----  /lib64/ld-2.12.so
00007f215c5c1000      4K rw---  /lib64/ld-2.12.so
00007f215c5c2000      4K rw---    [ anon ]
00007ffe6d6d3000    132K rw---    [ stack ]
00007ffe6d7ed000      8K r-x--    [ anon ]
ffffffffff600000      4K r-x--    [ anon ]
 total          3405716K
 ```


###### Linux 发行版所使用的线程模型、glibc 版本和内核版本    
cat /proc/version                查看内核版本   
getconf GNU_LIBPTHREAD_VERSION   查看线程模型
| 线程实现          | C 库     ---------            | 发行版                           | 内核   |
| ----------------- | ----------------------------- | -------------------------------- | ------ |
| LinuxThreads 0.7  | 0.71 (for libc5)  libc 5.x    | Red Hat 4.2                      |
| LinuxThreads 0.7  | 0.71 (for glibc 2) glibc 2.0. | Red Hat 5.x                      |
| LinuxThreads 0.8  | glibc 2.1.1                   | Red Hat 6.0                      |
| LinuxThreads 0.8  | glibc 2.1.2                   | Red Hat 6.1 and 6.2              |
| LinuxThreads 0.9  |                               | Red Hat 7.2                      | 2.4.7  |
| LinuxThreads 0.9  | glibc 2.2.4                   | Red Hat 2.1 AS                   | 2.4.9  |
| LinuxThreads 0.10 | glibc 2.2.93                  | Red Hat 8.0                      | 2.4.18 |
| NPTL 0.6          | glibc 2.3                     | Red Hat 9.0                      | 2.4.20 |
| NPTL 0.61         | glibc 2.3.2                   | Red Hat 3.0 EL                   | 2.4.21 |
| NPTL 2.3.4        | glibc 2.3.4                   | Red Hat 4.0                      | 2.6.9  |
| LinuxThreads 0.9  | glibc 2.2                     | SUSE Linux Enterprise Server 7.1 | 2.4.18 |
| LinuxThreads 0.9  | glibc 2.2.5                   | SUSE Linux Enterprise Server 8   | 2.4.21 |
| LinuxThreads 0.9  | glibc 2.2.5                   | United Linux                     | 2.4.21 |
| NPTL 2.3.5        | glibc 2.3.3                   | SUSE Linux Enterprise Server 9   | 2.6.5  |