---
title: linux内存布局和ASLR  
date: 2019-11-04
categories: develop 
author: yawei.zhang 
---

### ..1. 内存布局    

<!-- TOC -->

- [内存布局](#内存布局)
    - [基本布局](#基本布局)
    - [用户空间布局](#用户空间布局)
    - [TASKSIZE 定义](#tasksize-定义)
    - [栈地址](#栈地址)
    - [MMAP映射区起始地址](#mmap映射区起始地址)
    - [代码段开始地址](#代码段开始地址)
    - [BRK HEAP区开始地址随机](#brk-heap区开始地址随机)
- [ASLR在linux中的三个等级以及配置和禁用方法](#aslr在linux中的三个等级以及配置和禁用方法)

<!-- /TOC -->

#### ..1.1. 基本布局  
内核地址空间范围  [0XFFFF 0000 0000 0000, 0XFFFF FFFF FFFF FFFF]
用户地址空间      [0X0000 7FFF FFFF F000, 0X0000 0000 0000 0000]
不规范地址空间    不属于内核或者用户的地址空间属于不规范地址空间  

#### ..1.2. 用户空间布局

| - 用户空间布局 -              |
|-------------------------------|
| 0x0                           |
| 保留区                        |
| 代码段(PLT代码表部分)         |
| 代码段                        |
| 数据段(GOT) 只读              |
| 数据段(.got.plt) 惰性加载机制 |
| 数据段(Data)                  |
| BSS段                         |
| 堆空间(Heap)                  |
| ↓                             |
| 未分配区域                    |
| ↑                             |
| 内存映射区域(mmap)            |
| 栈空间(进程栈)                |
| TASK_SIZE                     |



#### ..1.3. TASK_SIZE 定义    
在X86的内核代码中, 默认的TASK_SIZE为 (1UL << 47) - 4096)   
即 
```
2^47-4096 => 0x7fff ffff f000    约为140T  
```
gdb调试程序默认会关闭aslr, 我们通过gdb运行一个程序, 然后对齐pmap可以得到如下内存分布:  
```
00007ffff7ffc000      4K r---- ld-2.27.so
00007ffff7ffd000      4K rw--- ld-2.27.so
00007ffff7ffe000      4K rw---   [ anon ]
00007ffffffde000    132K rw---   [ stack ]
ffffffffff600000      4K r-x--   [ anon ]
```

00007ffffffde000 + 132K = ‭0x7FFFFFFFF000‬  和内核代码中的宏定义一致



```C++
#ifdef CONFIG_X86_32
/*
 * User space process size: 3GB (default).
 */
#define IA32_PAGE_OFFSET    PAGE_OFFSET
#define TASK_SIZE        PAGE_OFFSET
#define TASK_SIZE_LOW        TASK_SIZE
#define TASK_SIZE_MAX        TASK_SIZE
#define DEFAULT_MAP_WINDOW    TASK_SIZE
#define STACK_TOP        TASK_SIZE
#define STACK_TOP_MAX        STACK_TOP

#else

#ifdef CONFIG_X86_5LEVEL
#define __VIRTUAL_MASK_SHIFT    (pgtable_l5_enabled() ? 56 : 47)
#else
#define __VIRTUAL_MASK_SHIFT    47
#endif

#define TASK_SIZE_MAX    ((1UL << __VIRTUAL_MASK_SHIFT) - PAGE_SIZE)

#define DEFAULT_MAP_WINDOW    ((1UL << 47) - PAGE_SIZE)

/* This decides where the kernel will search for a free chunk of vm
 * space during mmap's.
 */
#define IA32_PAGE_OFFSET    ((current->personality & ADDR_LIMIT_3GB) ? \
                    0xc0000000 : 0xFFFFe000)

#define TASK_SIZE_LOW        (test_thread_flag(TIF_ADDR32) ? \
                    IA32_PAGE_OFFSET : DEFAULT_MAP_WINDOW)
#define TASK_SIZE        (test_thread_flag(TIF_ADDR32) ? \
                    IA32_PAGE_OFFSET : TASK_SIZE_MAX)
#define TASK_SIZE_OF(child)    ((test_tsk_thread_flag(child, TIF_ADDR32)) ? \
                    IA32_PAGE_OFFSET : TASK_SIZE_MAX)

#define STACK_TOP        TASK_SIZE_LOW
#define STACK_TOP_MAX        TASK_SIZE_MAX

#define INIT_THREAD  {                        \
    .addr_limit        = KERNEL_DS,            \
}

extern unsigned long KSTK_ESP(struct task_struct *task);

#endif /* CONFIG_X86_64 */

```

#### ..1.4. 栈地址 

随机值大小为17G  = 0x3fffff000

load_elf_binary ->  setup_arg_page   
```C++
retval = setup_arg_pages(bprm, randomize_stack_top(STACK_TOP),
                 executable_stack);
```

```C++
#define __STACK_RND_MASK(is32bit) ((is32bit) ? 0x7ff : 0x3fffff)
#define STACK_RND_MASK __STACK_RND_MASK(mmap_is_ia32())

unsigned long randomize_stack_top(unsigned long stack_top)
{
    unsigned long random_variable = 0;

    if (current->flags & PF_RANDOMIZE) {
        random_variable = get_random_long();
        random_variable &= STACK_RND_MASK;
        random_variable <<= PAGE_SHIFT;
    }
    return PAGE_ALIGN(stack_top) - random_variable;
}
```


#### ..1.5. MMAP映射区起始地址 
```C++
load_elf_binary -> setup_new_exec -> arch_pick_mmap_layout ->arch_pick_mmap_base  
```

mmap的起始随机为   
STACK_TOP - 栈最大长度  - 间隙 -  随机值  

随机位数配置在//proc/sys/vm/mmap_rnd_bits  default=28   
默认随机最大值为0xFFFFFFF000

```C++

#define TASK_SIZE_MAX     ((1UL << 47) - PAGE_SIZE) //0x7FFFFFFFF000
#define TASK_SIZE     TASK_SIZE_MAX

#define STACK_TOP          TASK_SIZE
#define STACK_TOP_MAX          TASK_SIZE_MAX

/* 1GB for 64bit, 8MB for 32bit */
#define __STACK_RND_MASK(is32bit) ((is32bit) ? 0x7ff : 0x3fffff)
#define STACK_RND_MASK __STACK_RND_MASK(mmap_is_ia32())


static unsigned long stack_maxrandom_size(unsigned long task_size)
{
    unsigned long max = 0;
    if (current->flags & PF_RANDOMIZE) {
        max = (-1UL) & __STACK_RND_MASK(task_size == task_size_32bit());
        max <<= PAGE_SHIFT;
    }

    return max;
}

//task size为0x7FFFFFFFF000
//随机值为 random()& ((1UL << 28)   -1) 个页面, 即0x00FFFFFFF000
void arch_pick_mmap_layout(struct mm_struct *mm, struct rlimit *rlim_stack)
{

    mm->get_unmapped_area = arch_get_unmapped_area_topdown;

    arch_pick_mmap_base(&mm->mmap_base, &mm->mmap_legacy_base,
            arch_rnd(mmap64_rnd_bits), task_size_64bit(0),
            rlim_stack);  //proc/sys/vm/mmap_rnd_bits  default=28

}

//
static unsigned long arch_rnd(unsigned int rndbits)
{
    if (!(current->flags & PF_RANDOMIZE))
        return 0;
    return (get_random_long() & ((1UL << rndbits) - 1)) << PAGE_SHIFT;  
}

/*
 * 新布局直接调用*base = mmap_base(random_factor, task_size, rlim_stack);  
 */
static void arch_pick_mmap_base(unsigned long *base, unsigned long *legacy_base,
        unsigned long random_factor, unsigned long task_size,
        struct rlimit *rlim_stack)
{
    *legacy_base = mmap_legacy_base(random_factor, task_size);
    if (mmap_is_legacy())
        *base = *legacy_base;
    else
        *base = mmap_base(random_factor, task_size, rlim_stack);
}

//这是是随机值的上下限保护 栈至少要有128M 
//task size减去随机值, 再减去栈的大小, 栈的最小值为128M  
static unsigned long mmap_base(unsigned long rnd, unsigned long task_size,
                   struct rlimit *rlim_stack)
{
    unsigned long gap = rlim_stack->rlim_cur;
    unsigned long pad = stack_maxrandom_size(task_size) + stack_guard_gap;
    unsigned long gap_min, gap_max;

    /* Values close to RLIM_INFINITY can overflow. */
    if (gap + pad > gap)
        gap += pad;

    /*
     * Top of mmap area (just below the process stack).
     * Leave an at least ~128 MB hole with possible stack randomization.
     */
    gap_min = SIZE_128M;
    gap_max = (task_size / 6) * 5;

    if (gap < gap_min)
        gap = gap_min;
    else if (gap > gap_max)
        gap = gap_max;

    return PAGE_ALIGN(task_size - gap - rnd);
}

//max = (0x3fffff <<= 12)   = 0x3fffff000
static unsigned long stack_maxrandom_size(unsigned long task_size)
{
    unsigned long max = 0;
    if (current->flags & PF_RANDOMIZE) {
        max = (-1UL) & __STACK_RND_MASK(task_size == task_size_32bit());
        max <<= PAGE_SHIFT;
    }

    return max;
}

```


#### ..1.6. 代码段开始地址  
如果ELF文件为DYN类型  
加载地址会在 DEFAULT_MAP_WINDOW /3*2上增加一个arch_mmap_rnd随机值  
DEFAULT_MAP_WINDOW /3*2 = 0x555555554AAA
同mmap一样为 0x00FFFFFFF000 约1个T大小    
代码段起始位置约为93T +- 1T   

代码段数据段等整体随机  
```C++
if (interpreter) {
                load_bias = ELF_ET_DYN_BASE;
                if (current->flags & PF_RANDOMIZE)
                    load_bias += arch_mmap_rnd();
                elf_flags |= MAP_FIXED;
            } else
                load_bias = 0;
```

```C++  
    loc->elf_ex.e_entry += load_bias;
    elf_bss += load_bias;
    elf_brk += load_bias;
    start_code += load_bias;
    end_code += load_bias;
    start_data += load_bias;
    end_data += load_bias;
```

#### ..1.7. BRK HEAP区开始地址随机  
brk从BSS结束地址开始, 会有一个额外的随机arch_randomize_brk   
为固定的大小范围0x02000000, 大约为33M  
```C++
if ((current->flags & PF_RANDOMIZE) && (randomize_va_space > 1)) {
		/*
		 * For architectures with ELF randomization, when executing
		 * a loader directly (i.e. no interpreter listed in ELF
		 * headers), move the brk area out of the mmap region
		 * (since it grows up, and may collide early with the stack
		 * growing down), and into the unused ELF_ET_DYN_BASE region.
		 */
		if (IS_ENABLED(CONFIG_ARCH_HAS_ELF_RANDOMIZE) &&
		    loc->elf_ex.e_type == ET_DYN && !interpreter)
			current->mm->brk = current->mm->start_brk =
				ELF_ET_DYN_BASE;

		current->mm->brk = current->mm->start_brk =
			arch_randomize_brk(current->mm);
#ifdef compat_brk_randomized
		current->brk_randomized = 1;
#endif
	}

```

```C++
unsigned long arch_randomize_brk(struct mm_struct *mm)
{
	return randomize_page(mm->brk, 0x02000000);
}
```



### ..2. ASLR在linux中的三个等级以及配置和禁用方法    
* 系统全局配置
```
/proc/sys/kernel/randomize_va_space
0 = Disabled
1 = Conservative Randomization
2 = Full Randomization
```  

1. 关闭  
2. 保守随机化: 共享库 栈 mmap  vdso随机化   
3. 完全随机化:  包括brk分配的内存   
    2.1 代码段和数据段的随机化需要PIE位置无关可执行程序的支持  编译链接时添加 -fpie -pie   



* 修改/关闭系统配置  
```
# sysctl -w kernel.randomize_va_space=0
# echo 0 > /proc/sys/kernel/randomize_va_space
```

* 进程个性化设置: 进程描述符的成员personality设置 ADDR_NO_RANDOMIZE     
  * setarch $(uname -m) -R [--addr-no-randomize] [target exe]
  * 例如 ldd ./benchmark_fast 在aslr环境下会看到每次so的内存位置都在变化   
    * setarch $(uname -m) -R ldd ./benchmark_fast 这样去查看则是固定不变的  

