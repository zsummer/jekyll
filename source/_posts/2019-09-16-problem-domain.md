---
title: 问题的解决  
date: 2019-09-16
categories: develop 
author: yawei.zhang 
---

在认知心理学中, 问题解决的思维过程被描述为: 在问题空间下, 经过思考与推理, 达到目的的心理历程.    
该过程分为四个阶段  
* 发现问题
* 分析（明确）问题
* 提出假设  
* 验证假设  

其中问题空间(问题域)是指问题解决者对所要解决的问题的一切可能的认识状态, 包括对问题的初始状态和目标状态的认识, 以及如何从初始状态转化为目标状态的认知操作等.    

问题的解决就是对问题空间进行搜索, 找到一条从问题的初始状态到达目标状态的通路.   


## 问题解决的一般性阶段及其描述:    

* **问题的存在,发现和提出**  
* **定义问题域, 即定义问题集以及问题的约束集**  
* **从问题域中递归的构造可演算的计算(概念)模型**  
* **制定现实可执行的解决方案**  
* **实施并植入问题域所在现实环境验证**   
* **问题的解决**  

在这个过程中, 每个过程的推进都可能会伴随对其前向的阶段所做的处理发起修正, 在此过程中我们会不断的逼近'真正的问题'的问题定义, 以及'真正的问题解决'的结果, 从而采用形式化的方法寻找到最优的解决路径   

<!-- more --> 
### 问题的存在   
问题以不同的形式存在于不同的领域, 其核心是期望和现状的差异, 在不同的领域问题的描述方法和提出形式带有不同的领域特征, 例如:  

* 数学领域 问题是关于数学对象和结构的疑问, 比如很具体的'求X^2-1=0的解' 或者很一般的'为什么这些数在不同情况（领域）里面出现？请给出假说并证明之。'.     
* 商业领域 问题是现状和期望的差别 例如"某项目上线后各项数据低于预期"  (Root-Cause-Analyze来分析问题)
* 社会领域 问题是某类困境.  

更具体一些, 差异主要分为两种情况:
* 主体对上下文的理解和目标状态的理解程度的差异  
* 客体和目标状态的差异    
  
'期望'表明了问题属于认知领域, 必须要有抱有期望的主体存在才会认识或者感知问题, 问题不是独立存在的, 但是对于第二种差异则有时候可以解释为 "问题是独立于问题解决的主体存在的客观世界的一种表达方式", 只是被主体感知和表达出来, 因此 问题是否是独立存在的则有一定的争议,  但无论如何, 问题的提出必然依赖主体的认识和感知, 也就引入了解决问题的一个核心特征:   

**主体对问题的认识会存在一定程度的偏差, 人在解决问题的过程中会'不断的更准确的定义重新定义问题的描述, 使得主体对问题的认识偏差不断的缩小(认识偏差可无限趋近但无法绝对消除)', 从而更有利于发现符合逻辑的解释方法和解决方法.**       

* 问题
问题是期望和现状的差异, 是客观存在的, 是提问的基础.   
* 提问  
提问是把问题用合适的方法描述出来, 是解决问题的一个步骤.   
* 目标
目标是达成'解决问题'的某个具体状态  



### 对问题的思考   
* 基本的问题特征  
  * 定义明确的问题和定义不明确的问题  
    * 定义明确的问题具有特定的最终目标 并且有明确的预期解决方案 而定义不明确的问题则没有    
  
  * 复杂规模评估  
    * 组成问题的部分是否可枚举(不可枚举) 
    * 组成问题的部分是否具备同质性(异质性)  
    * 组成问题的部分是否彼此连通(连接的层次关系, 分配关系) 
    * 问题是否存在时间限制  
    * 问题是否对时间敏感 
    * 问题是否存在相位效应
    * 问题是否存在动态的不可预测性
    * 问题的来源是否透明可见  
    * 问题的发生过程是否透明可见  
    * 问题是否同时存在多个目标状态  
      * 多个目标之间是否存在以上可能导致问题复杂的'规模,时间,动态,透明'等复杂问题.
      * 部分目标是否存在冲突, 不表达等相容问题  

* 分析问题的基本障碍
  * 确认偏误
  * 心理(思维)定势
  * 功能固定性
  * 不必要的约束
  * 不相关的信息

* 结构化的问题分析方式   
  * 搜集和界定问题  
    * 搜集相关的问题, 期望的组成部分, 现状的组成部分, 差异的组成部分, 以及产生这些部分或者问题的原因.   
      * 确认期望结果集  
      * 确认非期望结果集(现状集)  
    * 提出各种假设并进行试验, 根据结果排除部分问题或者得出明确的结论   
    * 界定问题域的所属集合以及其约束.   
  * 逻辑树,问题域建模  
    * 寻找逻辑关系和结构关系  
      * 寻找时间/步骤顺序 (时序)  
      * 寻找空间/结构顺序 (拓扑)  
      * 寻找程度/重要性顺序 (主次非)  
    * 基本思维方法
      * 归纳推理  
        * 归类分组 概括其共性  以MECE为准则尽量做到不重不漏 
      * 演绎推理 
        * 三段论 排除问题或者得出明确的结论   
      * 质疑和提问  
  * 构建逻辑模型(逻辑树)  
    * 自上而下构建
      * 提出概括性模型并递归的拆解和具体化其组成部分,直到每个部分得到确认或者无法确认.   
    * 自下而上构建
      * 通过已确认的基础部分进行有序的组合构造/抽象出上层模型  
  * 验证和迭代模型   

### 计算机科学领域中的问题解决
* 定义问题域 (定义问题集以及问题的约束集)   
  * 包含期望实现的目标, 问题的上下文,   解决方案必须的基本功能和必须运行在的问题环境.   
* 通过形式化方法构建计算模型  
  * 计算模型目前有两大分支, 图灵机和lambda演算, 他们的计算能力等价.   
  * 使用数学语言对问题域进行描述和分析, 可以对模型的可靠性和稳健性进行论证, 但因成本问题形式化的方法可以进行分级实现,  设计规范, 实现规范, 验证规范.     
  * 构建的基本策略  
    * 通过处理部分有序集以对计算领域进行建模, 其中有序的元素解释为信息或者计算的部分, 其中次序较高的元素以一致的方式扩展旗下方元素的信息.  通过这个方式, 域理论以非常一般化的途径对直觉概念进行形式化的逼近和收敛.    
* 问题解决域 系统模型构建   
  * 问题解决域定义了解决问题的过程(实现路径)  
  * 问题解决域定义了解决问题的目标
  * 问题解决域定义了解决方案所必须运行的抽象环境.   
  * 解决方案从解决方案所运行的抽象环境植入到问题环境时, 这两个环境的差异往往是出错的原因.   
  
* 杂注   
  * 工程能力往往是针对问题解决域而言的, 在软件领域,  工作量往往是集中在工程实现层面的.   
  * 业务能力则是相对于问题域的而言,  对业务内容的敏感性, 对核心问题的洞察 .    
  * 数学素养, 几乎任何一个领域的成熟/发达程度都和这个领域中对形式化方法的渗透等级表现出极强的正相关.     


### 相关理论:

* 序理论 
  * 序理论研究数学排序的直觉概念上的各种二元关系.  
    * 从自然数的<=次序这个直觉概念很容易扩展到其他数的集合的排序, 这种大于或者小于另外一个数的概念 一般是记数系统(数制)的基本直觉. 
  * 序的概念是超出了具有直接,直观的顺序或者相对数量感觉的上下文, 在其他上下文中 序 可以获得 包含或者专用的概念,  在抽象上相当于子集关系.  
    * 通过指定 "<=关系必须是数学意义上的次序关系"这个属性,  序理论可以在一般性(普遍)架构下获得样例中的直觉次序
      * 这种抽象的方法可以在一般情况下得出许多定理而不必关注于任何特定的序的细节, 然后这些定理可以轻松的转移到不太抽象的应用程序中.   

  * (非严格)偏序  只对部分元素成立关系(部分可比 比如集合的包含关系, 并不是任何两个集合之间都存在包含关系)  
    * 偏序集合: 配备了偏序关系的集合    
    * 定义: 
      * 自反性:   对任意x∈A，有xRx  
      * 反对称性: 对任意x,y∈A，若xRy，且yRx，则x=y   
      * 传递性:   对任意x, y,z∈A，若xRy，且yRz，则xRz。
  * 全序：对集合中任意两个元素都有关系  
    * 全序关系必然是偏序关系 
  * 严格次序  
    * <=为平常次序,  <为严格次序  
  * 严格偏序 
    * 定义
      * 反自反性:   对任意x∈A，xRx必然不成立  
      * 非对称性: 对任意x,y∈A，若xRy不成立，且yRx不成立，则x=y ;   如果xRy成立则yRx一定不成立    
      * 传递性:   对任意x, y,z∈A，若xRy，且yRz，则xRz。
  * 可视化 
      * 可以使用hasse图等直观的表示部分有序的元素和关系 

 
* 域理论:  
  * 域是特定种类的偏序集合, 因此域理论也可以看做序理论的分支.   
  * 域理论通过处理部分有序集以对计算领域进行建模, 其中有序的元素解释为信息或者计算的部分, 其中次序较高的元素以一致的方式扩展旗下方元素的信息(分形).  通过这个方式, 域理论以非常一般化的途径对直觉概念进行形式化的逼近和收敛.  
    1. 通过对计算的每个域增加一个额外的元素 即形式化'部分信息'或者'不完全信息'的概念,  来构造演算的模型,  并且计算的域被装备一个'次序关系', 这其中的'未定义结果'或者说'部分信息'为最小元素. 
    2. 在这个模型之上, 计算的域总是部分有序的,  这种排序表示信息或者知识的层次, 元素在这个次序上越高, 它就更加明确和包含更多信息,  更低的元素表示不完全的知识或者中间结果.  
    3. 接着通过在这个域上重复的应用单调函数来精制结果, 到达一个不动点(递归定义中的f(x)=x, 闭包算子的“封闭要素")等价于完成一个计算.   
   
  * 收敛规范
    * 在域理论中有一个重要的概念是有向子集(例如A中任意两个元素a和b, 存在一个元素c(可能与a或者b相等)使得 a<=c 和 b <= c), 有向子集是顺序的非空子集, 其中任何两个元素的上限均为该子集的元素.  
      * 意味着有向子集的任何两个信息都被子集中的其他元素一致的扩展, 也因此可以将有向子集认为是一致的规范.   
      * 有向子集是域中没有两个元素矛盾的部分结果集, 这种可以比较的概念可以用做收敛序列的分析, 其中每个元素比上个元素更加具体.   在度量空间中, 序列的许多方面的作用类似域理论中的有向子集的作用.  
      * "有向, 偏序" 很自然的我们会对dcpo 有向完全偏序感兴趣  
      * 把指定的局部结果看做不完整的知识 这个基础的思想中可以得到另外一个理想的属性 : 最小元素的存在.   最小元素对没有信息的状态进行建模-大多数计算的开始地方, 或者可以把最小元素作为完全不返回任何结果的计算输出. (域理论中的不动点)  
  * 域的基础  
    * 因为我们无法计算无限大的对象 因此在实践中 "是否可以保证可以将域的所有元素作为更简单元素的极限来获得" 非常重要, 但是通常我们还是希望可以将它们任意近似地逼近.  

* 领域建模  
  * 领域分解  
    * 大领域分解成小领域  
  * 分析细化  
    * 面向对象法 问题域映射为解决域 
      * OOA 面向对象的分析方法   
      * OOD 面向对象的设计方法  
  * 基于获得的领域知识建模  
    * 确定实体和属性 (数据结构)  
    * 描述实体间静态关系 (数据结构和接口)   
    * 描述实体间动态关系 (核心逻辑, 状态机) 
    * 描述实体的生命周期 
    * 建立完整的映射
  * 验证迭代  

  
* Root-Cause-Analyze  
  * 核心问题和根本原因    
  * 产生问题的来源链路上, root位置的的原因为 root cause  根本原因.   
  * 不同的原因产生不同问题, 在组成'差异'的子集中, 核心问题来自于root cause, 其他问题 或者不是造成'差异'的主要部分,  也或者是属于核心问题的衍生.  

* 科学方法的基本循环步骤  (表征, 假设, 验证)    
  * 问题的认知与表述 (表征, 通过观察和分析明确问题)  
    * 问题需要满足 可观察 可经验（empirical） 可量度   
  * 提出假设  
    * 提出一个达到解决问题的目标       
  * 预测(解释)     
    * 对提出的假设或者理论进行归纳和演绎推论  
  * 实验   
    * 对上述表征 假设 预测进行测试验证   
  * 实验结果分析  提出新的假设   
  * 发布结果   