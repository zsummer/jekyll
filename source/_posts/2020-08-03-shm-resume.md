---
title: 共享内存RESUME综述 
date: 2020-08-03
categories: develop 
author: yawei.zhang 
mathjax: true
---

<!-- TOC -->

- [前言](#%E5%89%8D%E8%A8%80)
- [共享内存RESUME出现的背景: 为什么选择共享内存RESUME而不是集群冗余+故障转移](#%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98resume%E5%87%BA%E7%8E%B0%E7%9A%84%E8%83%8C%E6%99%AF-%E4%B8%BA%E4%BB%80%E4%B9%88%E9%80%89%E6%8B%A9%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98resume%E8%80%8C%E4%B8%8D%E6%98%AF%E9%9B%86%E7%BE%A4%E5%86%97%E4%BD%99%E6%95%85%E9%9A%9C%E8%BD%AC%E7%A7%BB)
    - [MMOACT相比传统互联网的异同](#mmoact%E7%9B%B8%E6%AF%94%E4%BC%A0%E7%BB%9F%E4%BA%92%E8%81%94%E7%BD%91%E7%9A%84%E5%BC%82%E5%90%8C)
    - [方案对比](#%E6%96%B9%E6%A1%88%E5%AF%B9%E6%AF%94)
    - [达成共识的解决方案](#%E8%BE%BE%E6%88%90%E5%85%B1%E8%AF%86%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88)
- [可行性验证](#%E5%8F%AF%E8%A1%8C%E6%80%A7%E9%AA%8C%E8%AF%81)
    - [隔离业务状态数据与非业务环境数据](#%E9%9A%94%E7%A6%BB%E4%B8%9A%E5%8A%A1%E7%8A%B6%E6%80%81%E6%95%B0%E6%8D%AE%E4%B8%8E%E9%9D%9E%E4%B8%9A%E5%8A%A1%E7%8E%AF%E5%A2%83%E6%95%B0%E6%8D%AE)
    - [隔离业务状态和业务逻辑数据和逻辑分离](#%E9%9A%94%E7%A6%BB%E4%B8%9A%E5%8A%A1%E7%8A%B6%E6%80%81%E5%92%8C%E4%B8%9A%E5%8A%A1%E9%80%BB%E8%BE%91%E6%95%B0%E6%8D%AE%E5%92%8C%E9%80%BB%E8%BE%91%E5%88%86%E7%A6%BB)
    - [最小化验证, FIRST GLOBAL STATE](#%E6%9C%80%E5%B0%8F%E5%8C%96%E9%AA%8C%E8%AF%81-first-global-state)
- [实践](#%E5%AE%9E%E8%B7%B5)
    - [技术难点](#%E6%8A%80%E6%9C%AF%E9%9A%BE%E7%82%B9)
    - [在随机化的ASLR中确立确定性的地址空间](#%E5%9C%A8%E9%9A%8F%E6%9C%BA%E5%8C%96%E7%9A%84aslr%E4%B8%AD%E7%A1%AE%E7%AB%8B%E7%A1%AE%E5%AE%9A%E6%80%A7%E7%9A%84%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4)
    - [提供地址无关的对象池,基础容器和数据结构](#%E6%8F%90%E4%BE%9B%E5%9C%B0%E5%9D%80%E6%97%A0%E5%85%B3%E7%9A%84%E5%AF%B9%E8%B1%A1%E6%B1%A0%E5%9F%BA%E7%A1%80%E5%AE%B9%E5%99%A8%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84)
    - [规范约束](#%E8%A7%84%E8%8C%83%E7%BA%A6%E6%9D%9F)
- [通用性上的挑战](#%E9%80%9A%E7%94%A8%E6%80%A7%E4%B8%8A%E7%9A%84%E6%8C%91%E6%88%98)
- [当前效果](#%E5%BD%93%E5%89%8D%E6%95%88%E6%9E%9C)

<!-- /TOC -->


## 前言    
**共享内存RESUME机制是指的: 通过将游戏状态数据保存在共享内存中, 当游戏进程crash后通过重启游戏服务器并attach已有的共享内存来恢复游戏状态, 以此达到玩家游戏体验在出现宕机时的连贯性, 提升游戏的容灾能力.**       


## 共享内存RESUME出现的背景: 为什么选择共享内存RESUME而不是集群冗余+故障转移   

### MMOACT相比传统互联网的异同   

在web领域中,  业务和数据分离, 从而达成'业务无状态化', 开发人员专注于业务本身, 状态数据的一致性问题和容灾问题转移到可以较为独立解决的数据存储领域, 这个领域有非常多的论文和解决方案, 以及成熟的服务等.     

而对于游戏领域来说, 互联网成熟的解决的方案很难在这个地方生效,  当然 对于外围系统来说, 我们仍然可以按照互联网成熟的解决方案进行布局, 例如聊天系统, 好友系统,  邮件系统, 日志系统,  或者一些游戏中的公会系统等.     


MMOACT的特性:  
* **CPU计算密集**   
  * 地图单位扫描选择 命中包围盒碰撞检测 战斗事件响应处理  AI的扫描检测,行为决策,  移动的寻路/碰撞避免/检测等    
  
* **IO密集**  
  * 视野内所有玩家的事件都要同步所有玩家(理想情况下), 这是一个$O(N^2)$的广播复杂度  
  * 大世界内视野范围较为开阔   
  
* **低延迟响应**   
  * 在战斗中, 一次攻击动作被拆解成逐帧开启和关闭的 霸体 无敌  攻击窗口 可闪避窗口 可打断窗口等流程片段, 一帧16.7ms  
  * 在战斗中每秒平均5~7米的移动距离, 100ms的延迟将会带来一个身位的偏差造成命中失败  
  * 弓箭的速度大约每秒50米, 30帧的客户端一帧就有两个身位的偏差  
  * 互联网骨干网20ms的延迟 每一点额外的延迟都会给同步带来较为巨大的压力.   
  
* **共享状态高频读写**   
  * 战斗单位与战斗单位之间, 战斗单位的模块与模块之间   
  * ACT战斗中实时响应判定的AI(大量事件和回调)  
  * 装备, 属性, 能量槽, 状态标签与技能和移动之间的相互引用与保证   
    * BUFF对属性的修改 标签的装载和卸载 子弹时间的进出等都需要严格保证对称   
  * 技能BUFF流程中跨战斗单位跨模块并需要严格保证时序的事件判定与脚本回执等   

* **重业务逻辑,需求易变**   
  * 业务类型繁多复杂且耦合, 见上栏'共享状态高频读写'   


传统互联网特性:  
* 数据规模大 用户量大 并发大  
* 轻业务, 重存储 对数据一致性要求较高    
  * 读写改查这几个基本操作可以涵盖绝大部分互联网业务的核心内容  
* 业务较为稳定  
* **延迟不敏感 通常都是秒级以上**.  
  * google Analytics速度报告中, 网页的平均加载时间为4~8秒   2秒打开网页我们会觉得飞快(秒开)  
  * 互动式直播和视频会议的延迟平均1~3秒  
  * 苹果支付服务器验证一个支付凭据需要3s-6s   
  * 45秒才能看视频   

游戏业务的形式化描述:   
$$
S_k=\begin{cases}
g(P, C), \qquad if \quad k = 0 \\\\
t(S_{k-1}, C, I_k),  \quad if \quad k \geq 1
\end{cases}
$$

> I是游戏状态变化的根本原因的集合 往往是各个玩家(按键)操作  
> S是游戏状态的集合 由众多状态子集组成  

> 该公式的描述: 
> * 游戏在第0个逻辑帧时 根据玩家信息P和游戏配置C 进行初始化运算g 得出初始化状态集合$S_0$    
> * 游戏在第k个逻辑帧时 根据前一个状态集合$S_{k-1}$和游戏配置C  根据第k帧收到的外部变化原因集合$I_k$ 进行逻辑t运算 得出第k个逻辑帧新的游戏状态集合$S_k$   


大部分互联网核心业务都能很好的进行业务和状态存储上的解耦, 以stateless形式在现有成熟的数据库相关的存储服务之上通过已有的成熟的解决方案来订制解决, 其核心往往是通过牺牲响应速度, 提高解决方案的复杂度来实现大规模高一致性的互联网需求.   

(12306的业务也不算复杂 但是难在大规模并发下, 状态之间难以解耦进行传统的分而治之而造成的)

而游戏服务, 很多时候游戏服务可以看成一个庞大的非确定状态机, 有非常庞大的状态集合, 实时响应所有玩家的请求并不断的推演下去,  并且其业务变更非常频繁,  往往是通过牺牲一定程度的可靠性和一致性来做到在有限的开发周期和资源里, 把一个尽可能满足策划设计和玩家体验的游戏做出来.   
实际上大部分的游戏项目也都在解决这个问题, 也因此互联网成熟的解决方案, 流行的解决方案 往往都离游戏项目比较远, 但是意思也并不是无关,  在靠近外围的架构和服务节点上, 我们仍然可以追着互联网潮流进行演进, 例如微服务.    



附图, MMO技能的基本流程如下:   
* 技能释放条件  --> 判断自身脚本 -->判断目标是否有脚本有则等待执行结果   
* 技能预处理   --> 判定  
* 技能释放成功  -->  判定  
* 技能命中开始扫描目标  --> 是否有反向过滤  --> 等待执行结果   
* 技能遍历所有选中目标
  * 即将对目标发起命中处理  --> 判定  
  * 对目标发起命中处理  
    * 遍历所有效果    
      * 即将对目标产生效果   --> 判定 
        * 如果是伤害则有 伤害预处理  -- >判定    
        * 如果是BUFF则有额外的buff流程判定  
      * 已经对目标产生效果  --> 判定  
        * 如果是伤害则有 伤害已经处理  -->判定  
    * 遍历所有效果完毕   
  * 已经对目标执行完命中处理  --> 判定   
* 技能遍历目标发起命中结束    
* 下一段命中  
* 技能即将结束  --> 判定  
* 技能已经结束   -->判定   

通常1V1战斗一次可能需要保证时序的同步点大约就有20个 而混战情况下则会有N倍的提升,  在非分布式的情况下, 所有的同步点带来的处理复杂度都是一次分支判定,  但是如果是分布式则会是一次rpc   .   
如果是共享内存下的消息队列实现  一次rpc来回则有10ms的延迟  

### 方案对比    
有成功案例的两种做法:   

一种不常见的BIGWORLD的做法(冗余系统&故障切换):   
* 以战斗单位进行解耦, 不同的战斗单位可以分布在不同节点   
* 游戏世界不按照场景地图划分, 而是按照战斗单位的负载动态切分   
* 所有单位进行跨物理节点的冗余, 故障后直接切换到备份单位继续战斗   
  
* 跨节点的战斗, 如果战斗系统同步点过多则不可避免的带来额外的延迟  
* RPC需求让系统变得更为复杂  开发和调试都会带来更多困难    
* 动态负载均衡难以实现  
* 需要面临的技术挑战过大参考资料和技术储备太少   


另外一种, 基于共享内存RESUME做法:   
* 状态数据持久化在共享内存中, 进程crash之后数据不丢失   
* 对使用者透明,  状态数据是在本地内存还是共享内存 对C/C++这种语言的使用者来说没有区别  
  * 经过完善的合理的包装设计, 可以做到业务人员对'共享内存'无感, 基本上做好状态和逻辑分离即可.   
* 对共享内存上的状态访问读写操作等同本地内存, 无额外性能消耗和处理延迟  
* RESUME后保持业务的连贯性, 对用户体验非常友好   
* 原理简单容易(分阶段)实现, 且每阶段都可验证,  有较多成功案例.   



可行性决策:   
* 提高可靠性   
  * 多点备份  故障转移     
    * 可在更多情景下做到可用性 例如网络故障 宕机   
    * 可以考虑在小项目或者中台部门进行MVP迭代到一定完成度   
  * 快速RESUME   
    * 只支持crash情况, 但是根据行业经验 绝大部分情况都是代码bug带来的crash   
* 保障业务连续性  
  * 都能做到业务连续性   
* 成本   
  * 共享内存RESUME方案无论是在开发阶段还是QA/运维部署等阶段成本都大大低于多点备份+故障转移的做法   
* 团队项目   
  * 立项之初团队规模很小 人力资源总预算有限   


### 达成共识的解决方案   

* 尽可能的拆分外围服务 以stateless集群+数据库存储方案来实现   
  * 例如好友 聊天 邮件等   

* 对无法做到stateless又难以拆分的管理节点和战斗节点进行RESUME设计.   
  * World管理节点  Scene战斗场景  


## 可行性验证   

### 隔离业务状态数据与非业务环境数据   
第一个问题是, 哪些数据应该放在共享内存中, 哪些数据不能放在共享内存中, 这个问题决定了具体的业务恢复情况.  

* **在游戏业务的RESUME机制中, 我们不做指令级的恢复,  也就是说, 首先 栈数据我们不会存放在共享内存中而是故障时直接丢弃**    
  * 一旦把栈放在共享内存中, 意味着我们要记录所有的指令状态和序列以及执行情况, 以及这意味着我们在发明一套新的支持resume的vm语言(这种发明有没有现实意义是另外一个新的问题) 而不是在C/C++语言之上resume我们的业务.    
  * crash可以发生在任意时刻的代码处理中, 难以避免的产生一些状态错误.    
    * 规范: 不能在共享内存中的对象或者内存中 有存在指向任何栈上或者堆上的指针   
    * 规范: 不能在共享内存中的对象或者内存中 有存在指向函数或者虚函数的指针 如果无法避免则需要在RESUME的时候恢复为正确的指针  
    * 规范: 如非必要, 不能有被栈管理的共享内存资源  
      * <font color=#999>例如使用智能指针获取共享内存上的某个对象, 然后经过一段复杂且经常变化的业务代码后release 控制权交给位于共享内存的map进行管理等.  这种情况一旦crash 这个对象无论crash多少次都会被永久挂起.</font>   
    * 规范: 尽可能的做好结构和流程的局部化设计, 并且做好兜底设计:<font color=#999>   
      * 例如 技能错误不影响战斗单位, 战斗单位错误不应该影响其他玩家等   
      * 例如, 创建一个技能实例:  
        * 获取创建实例的信息   
        * 用准备好的信息数据创建一个实例并填充一个基础状态, 再接下来的复杂逻辑中一旦crash, resume之后仍然能检测到技能实例的异常状态或者到期后自动清理   
        * 进行新实例创建后的脚本触发, 其他模块的同步调用通知等  
      * 例如 技能中修改属性   
        * 获取好单位的属性位置, 计算好要修改的值信息等   
        * 没有任何错误和异常的话 进行连续的赋值修改等 (这种操作通常不会crash)    
        * 执行一些变更通知 或者其他逻辑等  
        * 技能实例到期销毁, 根据记录的属性修改记录进行反向恢复  
      * 例如技能状态切换过程中出现错误  RESUME后正Tick检测到会再次执行切换操作</font>  
    * 规范: 内部分阶段REVIEW新人的代码 检查是否有不符合RESUME或者带来隐患的设计

* **隔离一些不能resume的三方库或者逻辑**    
  * 例如PROTOBUF不能做RESUME  那么就需要禁止在任何业务状态中有存储指向pbin的指针, 必须是用时查找读取, 启服初始化时或者RESUME时重新加载.   
  
  
* **消息/事件/任务队列等进行逻辑处理时应先标记当前'消息/事件/任务'在队列中已经被处理, 然后执行具体的逻辑. 一旦发生crash后不会重复执行该任务, 跳过故障流程**   
  * 如果需要关注处理结果则应该有对应的处理超时机制, resume后等待一段时间后进行超时处理   


### 隔离业务状态和业务逻辑(数据和逻辑分离)  
并不是一定要用ECS框架, 但是ECS框架或者类似的框架可以很好起到协助规范的执行情况   

* 业务状态和逻辑代码拆分后, 可以直观的观测和追溯状态的拓扑结构变更    
* 共享内存RESUME机制是对代码热更友好的, 如果考虑线上代码热更, 则方便进行数据结构的拓扑对比     
* 编写业务时因状态数据单独存放, 会起到'业务状态是放在共享内存而不是本地内存'的提醒作用, 减少心智负担.    
* 方便进行REVIEW检查   


### 最小化验证, FIRST GLOBAL STATE    

基础原理为, 定义单独的抽象类作为单个服务节点的索引起点(框架),  该节点下所有共享内存上的状态均以对象,静态内存数组等数据成员的形式聚合为该类的数据成员.     
在启服时候通过简单的静态计算算出来总大小并分配共享内存, 以此跑在共享内存之上,  在RESUME时则查找该共享内存并把框架类的指针指向共享内存区域.    





* 基础的shmget/shmat流程   
  * 启服创建共享内存, 并把global state指针指向共享内存完成构造初始化  
  * 启服绑定共享内存, 并把global state指针指向共享内存完成绑定和resume回调等  

* 所有游戏从global state这个Server类中聚合   例如  
  * global state: scene server  
    * map<场景>   
      * 场景:   
        * 地图大小   
        * 怪物列表   
    * map<玩家>   
      * 玩家:
        * 技能模块  
          * 技能
          * buff
          * 标签
        * 移动模块  
    * 事件队列   

## 实践   

### 技术难点   

* 代码段因代码变更或者ASLR随机化发生改变   
  * 函数指针变化 虚函数位置变化   

<font color=#888>
* 共享内存地址不固定情况下每次shmat会导致共享内存映射的地址发生变化   
  * 记录的地址指针错误
  * 只能使用地址无关的容器 例如std::array    
</font>

* 共享内存地址固定会因ASLR的HEAP/MMAP随机化而导致RESUME后冲突  
  * 关闭ASLR并估算一个不会冲突的位置  (版本更新, 新的so库 都会带来小的改变 但是只要能启服成功 RESUME也会成功)   
  * 不关闭ASLR并寻找一个不会被ASLR影响到区间  

* STL常用容器无法跑在共享内存下 并且是基础数据结构  
  * 实现常用的方便实现的容器 以静态内存的形式实现   
  * STATIC HASH MAP   (KV容器 地址无关)
  * STATIC LIST   (稳定迭代器 高性能队列 地址无关)
  * STATIC VECTOR  (数组 地址无关)  
  * 实现通用的内存分配器并编写std::allocator   
* 内存管理   
  * 对象池   
  * 内存池和内存分配器  
* 队列超时问题  
  * 
* 三方库的隔离  
  * 典型的PBin配置隔离  
* 业务恢复时间和对象池  
  
### 在随机化的ASLR中确立确定性的地址空间  
| - 用户空间布局 -              |
|-------------------------------|
| 0x0                           |
| 保留区                        |
| 代码段(PLT代码表部分)         |
| 代码段                        |
| 数据段(GOT) 只读              |
| 数据段(.got.plt) 惰性加载机制 |
| 数据段(Data)                  |
| 数据段(BSS)                         |
| 堆空间(Heap)                  |
| ↓                             |
| 未分配区域                    |
| ↑                             |
| 内存映射区域(mmap)            |
| 栈空间(进程栈)                |
| TASK_SIZE                     |

地址空间配置随机加载（英语：Address space layout randomization，缩写ASLR，又称地址空间配置随机化、地址空间布局随机化）是一种通过随机放置进程关键数据区域的地址空间来防止攻击者能可靠地跳转到内存的特定位置, 从而防范这类内存损坏漏洞被利用的计算机安全技术, 例如常见的Return-to-libc攻击.  

这些数据区域一般包括代码段 数据段 堆区 栈区 mmap  动态库等,  其中涉及代码段的随机一般需要代码位置无关化的支持(PIC PIE机制), 不同版本的操作系统和内核版本, 在ASLR的实现上以及默认系统选项都会有细节的不同, 在X86-64位最高等级下, 我们可以找到不会被随机到但是可以通过mmap建立有效映射的(0x0000 7F00 0000 0000 ~ 0x0000 5655 5555 5555)大约44T的地址空间(128T的1/3), 前者为mmap开始位置 后者为HEAP(BRK)开始位置.   

在实践中, 我们把共享内存的位置设置在靠中间的位置, 给系统mmap和heap留有足够的空间.   例如 0x0000 7000 0000 000,  这样和MMAP区域有17T的间隙, 充分安全, 无论ASLR开什么级别RESUME多少次 始终不会和共享内存选定的地址产生冲突   

细节内核代码分析见:[linux内存布局和ASLR下的可分配地址空间](https://zsummer.github.io/2019/11/04/2019-11-04-aslr/)




### 提供地址无关的对象池,基础容器和数据结构  


### 规范约束   

## 通用性上的挑战      


## 当前效果   



性能对比  






