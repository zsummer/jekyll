---
title: 游戏(技能)中的脚本设计
date: 2020-06-16
categories: develop 
author: yawei.zhang 
---

## 脚本设计   

### 前言 
每种语言都有自己的惯用思维, 面对领域需求时, 也应该在不同的语言思维环境下寻找解决方案, 而不是生搬硬套另外一种语言的特性, 但是从可计算性的角度上来看, 相同需求的良好解决方案往往具备很强的相似性.  

那么更具体的领域中, 我们说说技能系统的场景:  

技能系统的复杂度偏向问题域, 如果不去约束问题域的规模, 最好的解决方案一定是通过脚本化方式让技能的设计者直接去写设计者期望的战斗逻辑. 但是作为一门通用的语言, 是需要转化为一个简洁的, 低门槛的领域语言.  

这里不讨论如何拆解该系统所面对的问题域, 如何抽象出解决域的模型等, 这部分在之前的技能系统相关的PPT中已经描述过,  这里主要关注的是, 在使用脚本的情况下, 我们如何对脚本这部分进行更具体的设计.   

* 作为开发者, 更关注的是开发测试成本, 即用最简洁的代码, 一劳永逸的提供最丰富的上层接口.   
* 作为设计者, 更关注的是是否提供了足够的封装, 隐藏掉不需要关心的功能实现细节以及流程细节, 并且能够总是通过简单的if else call来完成所有决策, 或者用简单的枚举或者画图 打钩完成所有决策而不需要操刀脚本编写.  
  * 更进一步的, 从设计者角度, 按照配置的出场频度和复杂度应该有如下的方案排序:<font color=#f33 size=3>   
    * 几乎总是需要配置的:  默认配置方案,  什么都不需要做就是应该有的功能或者流程   
    * 次高频:  通过开关来切换功能或者流程   
    * 高频: 通过枚举来完成多功能或者多流程case   
    * 高频略复杂: 通过枚举+固定的跟随参数来完成   
    * 高频略复杂: 开发人员编写特定的功能模块, 条件模块, 并提炼出参数以特定枚举方式提供   
    * 中低频复杂条件: 嵌入简短的脚本, 通过数据接口+脚本提供的布尔表达式来完成   
    * 中低频复杂逻辑: 开发人员使用脚本封装好逻辑, 提供脚本接口供设计者配置 </font>      

对于一些硬核的项目, 例如设计者本身就有一定的CS基础或者对脚本比较熟悉,  那么其实作为开发者只要提供基础功能和接口, 就可以完全用脚本来铺展所有的工作了  

但是不同的项目有不同的思维风格, 考虑进一步压缩编写脚本的情景, 或者说我们希望把要手动写脚本才能解决问题的范围从例如40%压缩到5% ...    
除了**数据驱动相关的组合拳, 以堆开发量减少这个范围外**, 还考虑了另外一个路径来减少开发成本和代码风险.   

<font color=#f33 size=3>   

* 在配置接口和脚本接口之间添加一个中间层脚本, 使用脚本语言自身的封装特性进一步简化接口, 并且支持热更.      
  * 在中间层编写复杂逻辑的封装, 保证C++内核的代码稳定性和质量稳定性   
* 在配置层增加模版机制或者脚本片段选择机制, 提供更简洁高效的脚本配置途径.  
* 在部分中低频数据驱动的配置方案中, 采用翻译为脚本的快速形式, 减少代码风险提供开发速度   
</font>  
  

<!--more -->

### how to    
如何实现这样一套完善的脚本体系呢 ?   

* 提炼技能系统的meta数据   
  > 这里的meta数据, 意思是把一个能表征技能状态和数据的关键元素提取出来单独维护, 它足够小但足够提供我们关心的所有信息.  例如初始状态, 当前状态, 可追溯的来源信息, 相关联的配置ID, 上下文等.    
  > 这份meta数据会成为脚本的基础数据环境, 通过这个meta信息我们可以查询相关的配置 状态, 以作为某些条件的判定依据, 以及新的行为的参数.    
  > 必要时我们可以拷贝这份meta数据, 或者伪造修饰部分数据来提供更特殊的环境实现.    

* 基础的脚本胶水接口实现 (开发向低级接口)   
  > 一次性提供所有meta数据的访问接口   
  > 提供C侧基于meta数据的功能函数封装, 尽可能的做到原子性   

* 编写模板类, 提供易用 易读 易使用的高级接口  
  > 一次性翻译低级接口到高级接口,  这个过程会隐藏掉例如meta数据本身访问等   
  > 编写高级封装    

* 在C++代码中打桩  
  > 把来自设计者的脚本片段和合成一个临时函数并压栈  
  > 把meta数据和调用信息压栈, 作为临时函数的参数去执行.   
  > 这里为了简化不同流程的桩点环境和不同事件的桩点环境不同, 并不会编写不同的桩点代码而是统一使用meta数据,  这样再脚本系统的实现上就做到了统一的埋点处理, 极大的减少了因此带来的桩点代码量.       
  > 桩点中来自策划的脚本片段实际执行会经过'模板类'这个中间层,  而这个中间层存储在可热更的单独文件中.   
  > 打桩的脚本代码在首次执行时会处理为字节码提高性能, 热更配置会清除字节码.    
  > 模板类脚本也为字节码 可热更.   

* 注意项:  对脚本调用可能存在嵌套, 例如在脚本事件中触发新的脚本甚至重入  
  > 在每段可能会触发脚本的关键路径上进行stack计数, 超过计数block掉该流程.   
  > 脚本环境支持嵌套, 或者说脚本环境(包含技能meta和脚本环境实例)应该是放在栈上. 

### detail      

#### lua的OOP模拟   
需要解释下是 lua没有类的概念, 只有实例(table).  但是lua的table是可以聚合函数和数据的, 并且存在metatable这种元表概念, 因此在在lua的语法特性中我们可以用以下方式来完成一个接近OOP的模拟, 基本思路如下:  
  * 构造一个全局的table实例作为创建实例的metatable(类的概念)   
  * 提供一个公共的new接口来创建一个新表, 并设置好metatable的关系. (实例化)  
  * 以:形式来编写所有函数完成C++this指针的作用, 即所有函数的实现默认第一个参数为实例自身, 调用时默认用自身作为函数的第一个参数   
  * 其简洁的实现形式如下:   

  ```Lua
  -- 定义全局table  
  meta = {}

  --数据成员 
  meta.class_name = "meta";  

  --函数成员
  function meta:desc(msg)
      print(self.class_name .. ": " .. msg)
  end

  --这个:是一个语法糖, 等价代码:
  --[[
  function meta.desc(self, msg)
      print(self.class_name .. ": " .. msg)
  end
  ]]--

  --实例化方法
  function meta.New(...)
      local inst = {...}  
      setmetatable(inst, { __index = meta })   --设置metatable 当inst中不存在某个键，会读出meta相应的元方法   
      return inst
  end

  --实例化一个meta的实例  
  local inst = meta.New()

  --修改新实例的class_name为inst    
  inst.class_name = "inst"   

  --子类并没有desc方法 会尝试读meta的desc 并把inst实例以self参数传入该方法    
  inst:desc("new inst")

  ```
* output  
  >  inst: new inst

 #### 实际应用  

 * 统一的桩点代码
  ```Lua
  return function (skill_meta, result, ...)
    local inst_env = {skill_meta, result, ...}
    setmetatable(inst_env, { __index = meta_env })
    do 
       --配置开始
       --inst_env:cast_skill(...)
       --配置结束
    end 
    return 0; 
  end 
  ```

* 

* ...
  


