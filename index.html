<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="en">
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.2" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.2" />






<meta property="og:type" content="website">
<meta property="og:title" content="关于夏天的一切">
<meta property="og:url" content="https://zsummer.github.io/index.html">
<meta property="og:site_name" content="关于夏天的一切">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="夏天">
<meta name="twitter:card" content="summary">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://zsummer.github.io/"/>





  <title>关于夏天的一切</title>
  














<meta name="generator" content="Hexo 4.2.1"><!-- hexo-inject:begin --><!-- hexo-inject:end --></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="en">

  
  
    
  

  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="container sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">关于夏天的一切</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">我总觉得对你的爱很美</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://zsummer.github.io/2020/08/03/2020-08-03-shm-resume/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="夏天">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="关于夏天的一切">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/08/03/2020-08-03-shm-resume/" itemprop="url">共享内存RESUME综述</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-08-03T00:00:00+08:00">
                2020-08-03
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/develop/" itemprop="url" rel="index">
                    <span itemprop="name">develop</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <!-- TOC -->

<ul>
<li><a href="#%E5%89%8D%E8%A8%80">前言</a></li>
<li><a href="#%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98resume%E5%87%BA%E7%8E%B0%E7%9A%84%E8%83%8C%E6%99%AF-%E4%B8%BA%E4%BB%80%E4%B9%88%E9%80%89%E6%8B%A9%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98resume%E8%80%8C%E4%B8%8D%E6%98%AF%E9%9B%86%E7%BE%A4%E5%86%97%E4%BD%99%E6%95%85%E9%9A%9C%E8%BD%AC%E7%A7%BB">共享内存RESUME出现的背景: 为什么选择共享内存RESUME而不是集群冗余+故障转移</a><ul>
<li><a href="#mmoact%E7%9B%B8%E6%AF%94%E4%BC%A0%E7%BB%9F%E4%BA%92%E8%81%94%E7%BD%91%E7%9A%84%E5%BC%82%E5%90%8C">MMOACT相比传统互联网的异同</a></li>
<li><a href="#%E6%96%B9%E6%A1%88%E5%AF%B9%E6%AF%94%E5%92%8C%E5%86%B3%E7%AD%96">方案对比和决策</a></li>
</ul>
</li>
<li><a href="#%E5%8F%AF%E8%A1%8C%E6%80%A7%E5%88%86%E6%9E%90%E5%92%8C%E9%AA%8C%E8%AF%81">可行性分析和验证</a><ul>
<li><a href="#%E9%9A%94%E7%A6%BB%E4%B8%9A%E5%8A%A1%E7%8A%B6%E6%80%81%E6%95%B0%E6%8D%AE%E4%B8%8E%E9%9D%9E%E4%B8%9A%E5%8A%A1%E7%8E%AF%E5%A2%83%E6%95%B0%E6%8D%AE">隔离业务状态数据与非业务环境数据</a></li>
<li><a href="#%E9%9A%94%E7%A6%BB%E4%B8%9A%E5%8A%A1%E7%8A%B6%E6%80%81%E5%92%8C%E4%B8%9A%E5%8A%A1%E9%80%BB%E8%BE%91%E6%95%B0%E6%8D%AE%E5%92%8C%E9%80%BB%E8%BE%91%E5%88%86%E7%A6%BB">隔离业务状态和业务逻辑数据和逻辑分离</a></li>
<li><a href="#%E6%9C%80%E5%B0%8F%E5%8C%96%E9%AA%8C%E8%AF%81-first-global-state">最小化验证, FIRST GLOBAL STATE</a></li>
</ul>
</li>
<li><a href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E5%92%8C%E5%AE%9E%E8%B7%B5">解决方案和实践</a><ul>
<li><a href="#resume%E7%8A%B6%E6%80%81%E9%87%8D%E5%BB%BA%E6%81%A2%E5%A4%8D%E7%9A%84%E5%9F%BA%E7%A1%80%E9%97%AE%E9%A2%98">RESUME状态重建/恢复的基础问题</a></li>
<li><a href="#%E5%9F%BA%E7%A1%80%E9%97%AE%E9%A2%98%E4%BB%A5%E5%8F%8A%E8%A7%A3%E5%86%B3%E7%AD%96%E7%95%A5">基础问题以及解决策略</a><ul>
<li><a href="#%E9%99%84-%E5%9C%A8%E9%9A%8F%E6%9C%BA%E5%8C%96%E7%9A%84aslr%E4%B8%AD%E7%A1%AE%E7%AB%8B%E7%A1%AE%E5%AE%9A%E6%80%A7%E7%9A%84%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4">附: 在随机化的ASLR中确立确定性的地址空间</a></li>
</ul>
</li>
<li><a href="#%E5%AF%B9%E8%B1%A1%E6%B1%A0%E5%92%8C%E5%9F%BA%E7%A1%80%E5%AE%B9%E5%99%A8%E7%AD%89%E9%80%9A%E7%94%A8%E6%80%A7%E8%AE%BE%E8%AE%A1">对象池和基础容器等通用性设计</a><ul>
<li><a href="#%E5%AF%B9%E8%B1%A1%E6%B1%A0%E5%AE%9A%E9%95%BF%E5%86%85%E5%AD%98%E6%B1%A0%E5%AF%B9%E8%B1%A1%E5%88%86%E9%85%8D%E5%9B%9E%E6%94%B6%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%9F%BA%E7%A1%80%E8%AE%BE%E8%AE%A1">对象池定长内存池+对象分配回收接口的基础设计</a></li>
<li><a href="#%E5%9C%B0%E5%9D%80%E6%97%A0%E5%85%B3%E7%9A%84%E5%AE%B9%E5%99%A8%E5%AE%9E%E7%8E%B0">地址无关的容器实现</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E5%B0%8F%E7%BB%93">小结</a><ul>
<li><a href="#%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%E5%85%B6%E4%BB%96%E9%97%AE%E9%A2%98">需要注意的其他问题</a></li>
<li><a href="#%E9%80%9A%E7%94%A8%E6%80%A7%E4%B8%8A%E7%9A%84%E6%8C%91%E6%88%98-%E5%9C%A8%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98%E4%B8%8A%E6%9E%84%E5%BB%BA%E9%80%9A%E7%94%A8%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%99%A8">通用性上的挑战: 在共享内存上构建通用内存管理器</a></li>
</ul>
</li>
</ul>
<!-- /TOC -->


<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>共享内存RESUME机制是指的: 通过将游戏状态数据保存在共享内存中, 当游戏进程crash后通过重启游戏服务器并attach已有的共享内存来恢复游戏状态, 以此达到玩家游戏体验在出现宕机时的连贯性, 提升游戏的容灾能力.</strong>       </p>
<h2 id="共享内存RESUME出现的背景-为什么选择共享内存RESUME而不是集群冗余-故障转移"><a href="#共享内存RESUME出现的背景-为什么选择共享内存RESUME而不是集群冗余-故障转移" class="headerlink" title="共享内存RESUME出现的背景: 为什么选择共享内存RESUME而不是集群冗余+故障转移"></a>共享内存RESUME出现的背景: 为什么选择共享内存RESUME而不是集群冗余+故障转移</h2><h3 id="MMOACT相比传统互联网的异同"><a href="#MMOACT相比传统互联网的异同" class="headerlink" title="MMOACT相比传统互联网的异同"></a>MMOACT相比传统互联网的异同</h3><p>在web领域中,  业务和数据分离, 从而达成’业务无状态化’, 开发人员专注于业务本身, 状态数据的一致性问题和容灾问题转移到可以较为独立解决的数据存储领域, 这个领域有非常多的论文和解决方案, 以及成熟的服务等.     </p>
<p>而对于游戏领域来说, 互联网成熟的解决的方案很难在这个地方应用,  当然 对于外围系统来说, 我们仍然可以按照互联网成熟的解决方案进行布局, 例如聊天系统, 好友系统,  邮件系统, 日志系统,  或者一些游戏中的公会系统等.     </p>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/2020/08/03/2020-08-03-shm-resume/#more" rel="contents">
              Read more &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://zsummer.github.io/2020/07/24/2020-07-24-state_sync/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="夏天">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="关于夏天的一切">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/07/24/2020-07-24-state_sync/" itemprop="url">多人游戏中的同步机制综述</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-07-24T00:00:00+08:00">
                2020-07-24
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/develop/" itemprop="url" rel="index">
                    <span itemprop="name">develop</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <!-- toc -->

<ul>
<li><a href="#前言">前言</a></li>
<li><a href="#同步问题的产生和基本策略机制">同步问题的产生和基本策略机制</a></li>
<li><a href="#同步模型的一般性描述">同步模型的一般性描述</a></li>
<li><a href="#游戏中的状态一致性问题">游戏中的状态一致性问题</a></li>
<li><a href="#同步过程中的抖动和延迟问题">同步过程中的抖动和延迟问题</a></li>
<li><a href="#优化网络延迟和抖动">优化网络延迟和抖动</a><ul>
<li><a href="#当前的网络环境">当前的网络环境</a></li>
<li><a href="#工具">工具</a></li>
<li><a href="#链路层延迟的优化">链路层延迟的优化</a></li>
<li><a href="#tcp还是udp">TCP还是UDP</a></li>
<li><a href="#tcp下的延迟和抖动优化">TCP下的延迟和抖动优化</a></li>
<li><a href="#udp的优化">UDP的优化</a></li>
</ul>
</li>
<li><a href="#时钟选择和时钟同步">时钟选择和时钟同步</a><ul>
<li><a href="#实现">实现</a></li>
</ul>
</li>
<li><a href="#移动-影子跟随算法和优化内插">移动: 影子跟随算法和优化(内插)</a></li>
<li><a href="#常见的延迟隐藏手段">常见的延迟隐藏手段</a></li>
<li><a href="#移动-航位推测法外推">移动: 航位推测法(外推)</a></li>
<li><a href="#插值和外推-以及常用算法">插值和外推, 以及常用算法</a><ul>
<li><a href="#内插值常用算法">内插值常用算法</a></li>
<li><a href="#外插值常用算法">外插值常用算法</a></li>
</ul>
</li>
<li><a href="#命中-延迟补偿">命中: 延迟补偿</a><ul>
<li><a href="#延迟补偿的局限">延迟补偿的局限</a></li>
</ul>
</li>
<li><a href="#逻辑预演和客户端提交命中">逻辑预演和客户端提交命中</a><ul>
<li><a href="#满足进攻者的精彩时刻">满足进攻者的精彩时刻</a></li>
</ul>
</li>
<li><a href="#提高tickrate">提高TickRate</a></li>
<li><a href="#回退-快播-和解">回退 快播 和解</a></li>
<li><a href="#案例分析部分">案例分析部分</a></li>
<li><a href="#引用文献">引用文献</a></li>
</ul>
<!-- tocstop -->

<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文中所有内容默认都基于逻辑描述, 逻辑状态,逻辑处理的逻辑游戏世界,  纯本地表现类, 总是通过逻辑世界单向导出的渲染计算等, 均不在本篇文章讨论范畴.  </p>
<h2 id="同步问题的产生和基本策略机制"><a href="#同步问题的产生和基本策略机制" class="headerlink" title="同步问题的产生和基本策略机制"></a>同步问题的产生和基本策略机制</h2><p><strong>在多人游戏或者基于CS网络模型的游戏中, 玩家所在的游戏世界并非全由本地生成和修改, 必须不断从服务器或者其他玩家获得最新的信息来完成游戏世界的共享体验, 在多人实时交互的游戏中,  相当于每个人都维护一个’完整世界’的副本, 并保证每个人维护的副本之间一致性和实时性, 不同游戏对副本的规模复杂度以及对一致性和实时性的要求不同, 并随着网络环境的变化在不同的历史时期下演化出了多种同步方案.</strong>   </p>
<p>在所有的同步方案中, 有两种最基础也最常见的同步机制, 即状态同步和帧同步, 其基本机制和区别为:  </p>
<ul>
<li><strong>状态同步: 通过同步游戏中的各种状态来保证游戏世界副本的一致性, 基本流程如下:</strong>   <ul>
<li>服务器维护权威完整副本  客户端维护本地副本 <font color=#ccc> (可以只维护部分副本) </font>   </li>
<li>客户端上行请求到服务器 服务器进行完整的逻辑演算 并将发生改变的状态下行给客户端   </li>
<li><font color=#ccc>客户端基于本地副本进行预演和状态预刷新 </font>  </li>
<li>客户端用来自服务器的状态数据刷新本地副本, 对齐服务器副本   <ul>
<li><font color=#ccc>客户端如果有因预演导致的数据不对齐需要通过强同步/回滚/和解等机制达成最终对齐</font>   <ul>
<li><font color=#ccc>快照类同步方式总是全量对齐</font>   </li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li><p><strong>帧同步: 泛指通过一致的初始状态, 一致的输入事件和一致的逻辑处理, 从而得到相同的计算结果来保证游戏世界副本的一致性的同步方案</strong>    </p>
<ul>
<li><p>该术语为泛指, 所有通过确定性算法,以保证输入一致来得出相同游戏流程结果的同步均可泛称为帧同步.   </p>
</li>
<li><p>最早有对等网络的锁步同步, 发展为非对等网络的主机锁步同步, 再到后来的bucket同步以及现在比较流行的定时不等待乐观帧同步  </p>
</li>
<li><p>锁步同步:  </p>
<ul>
<li>客户端定时(比如每五帧为一个关键帧)上传一轮输入信息   </li>
<li>服务器收到所有输入信息后广播给其他所有客户端  </li>
<li>客户端用服务器发来的更新消息中的输入信息进行游戏(如果是对称网络, 这个过程则是广播自己输入信息和搜集所有其他客户端的输入信息)     </li>
<li>如果客户端进行到下一个关键帧(5帧后)时没有收到服务器的更新消息则等待   </li>
<li>如果客户端进行到下一个关键帧时已经接收到了服务器的更新消息, 则将上面的数据用于游戏, 并采集当前鼠标键盘输入发送给服务器, 同时继续进行下去   </li>
<li>服务端采集到所有数据后再次发送下一个关键帧更新消息   </li>
</ul>
</li>
<li><p>定时不等待:     </p>
<ul>
<li>相对于锁步同步来说, 服务器会定时下发收集到的信息,  并根据收集到的信息调整关键帧的间隔,  没有在指定间隔内收到的消息会排在下一次关键帧或者丢弃   </li>
<li>相对于锁步同步来说, 任何客户端的卡顿不会阻塞其他玩家   </li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>这两种同步模型本质上并不冲突, 并且在细节上会相互补充优化,  常见的为在状态同步这种弱一致性框架下添加确定性演算来增加同步的准确性, 在确定性的帧同步下隔离出来部分状态进行优化增加流畅性,  从模型角度来说, 在复杂的同步需求中, 状态同步总是比帧同步有更多的扩展和调优空间, 典型的案例如UE4和UNITY中的DS服务器.</strong>   </p>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/2020/07/24/2020-07-24-state_sync/#more" rel="contents">
              Read more &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://zsummer.github.io/2020/07/21/2020-07-21-math_of_combat/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="夏天">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="关于夏天的一切">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/07/21/2020-07-21-math_of_combat/" itemprop="url">数值模型 战斗属性和判定公式</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-07-21T00:00:00+08:00">
                2020-07-21
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/develop/" itemprop="url" rel="index">
                    <span itemprop="name">develop</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <h2 id="战斗属性"><a href="#战斗属性" class="headerlink" title="战斗属性"></a>战斗属性</h2><p><strong>战斗属性属于战斗单位的简单数据字段,  提供基础的数据读写操作(相对于magic state而言).</strong><br>在实践中 一般战斗属性还包含从配置文件中load数据, 一级战斗属性到二级战斗属性的封装, 以及按照功能,战斗单位层级的划分等.    </p>
<h2 id="战斗属性的设计和实现"><a href="#战斗属性的设计和实现" class="headerlink" title="战斗属性的设计和实现"></a>战斗属性的设计和实现</h2><h3 id="字段表设计"><a href="#字段表设计" class="headerlink" title="字段表设计"></a>字段表设计</h3><p>字段表在设计上隶属于’接口层’这个概念, 简单直接, 易于访问和同步处理时目的.    </p>
<p>在C++中 通常考虑用一块静态数组的内存来表示   </p>
<table>
<thead>
<tr>
<th>A</th>
<th>A</th>
<th>A</th>
<th>A</th>
<th>A</th>
<th>A</th>
<th>A</th>
<th>A</th>
<th>A</th>
</tr>
</thead>
<tbody><tr>
<td>字段名</td>
<td>HP</td>
<td>MP</td>
<td>ATK</td>
<td>CRIT</td>
<td>RESIST CRIT</td>
<td>HIT RATE</td>
<td>MISS RATE</td>
<td>…</td>
</tr>
<tr>
<td>转换类型</td>
<td>INT</td>
<td>INT</td>
<td>INT</td>
<td>INT</td>
<td>INT</td>
<td>FLOAT</td>
<td>FLOAT</td>
<td>…</td>
</tr>
</tbody></table>
<p>这种字段表的设计有以下优点和特性:</p>
<ul>
<li>性能非常高   </li>
<li>可以直接操作,遍历内存 方便统一管理  </li>
<li>以数组下标完成ID的设计, 并使用BIT位进行脏数据标记辅助进行增量同步  </li>
<li>初始化约定为0,  进行初始同步时只同步非0数据即可,  后续采用增量同步, 减少同步量   </li>
<li>字段表中的数据修改可以由属性表进行托管结算 也可以直接set   <ul>
<li>通常战斗属性均为属性表托管结算和刷新 不能直接set   </li>
<li>通常能量条类属性直接进行set </li>
<li>复杂的属性一般由多个属性功能完成 例如<ul>
<li>血量上限 (战斗属性)   </li>
<li>当前血量 (属于能量条类, 则特殊条件下以’血量上限属性’为依据进行set  例如出生满血)   </li>
</ul>
</li>
</ul>
</li>
</ul>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/2020/07/21/2020-07-21-math_of_combat/#more" rel="contents">
              Read more &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://zsummer.github.io/2020/06/18/2020-06-18-skill-tag/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="夏天">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="关于夏天的一切">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/06/18/2020-06-18-skill-tag/" itemprop="url">技能系统中的标签机制</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-06-18T00:00:00+08:00">
                2020-06-18
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/develop/" itemprop="url" rel="index">
                    <span itemprop="name">develop</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <h1 id="技能系统中的标签机制"><a href="#技能系统中的标签机制" class="headerlink" title="技能系统中的标签机制"></a>技能系统中的标签机制</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><hr>
<p>对于一个大规模系统的建模 一定离不开常见的分类手段, 而分类要根据系统中的元素以及元素之间的关系来作为划分依据, 从而采用不同策略<br>技能系统中的配置以’技能’和’效果’作为完整的配置单位, 所有的技能和效果之间的关系则是多维的图的拓扑关系的, 例如:</p>
<blockquote>
<p>眩晕BUFF: 禁止普通移动, 禁止常规技能释放,<br>定身BUFF: 禁止普通移动<br>金身BUFF: 禁止普通移动, 禁止所有技能释放,  不可被眩晕/禁止所有效果(受击, 伤害, debuff/buff等)<br>冰冻BUFF: 禁止普通移动, 禁止所有技能释放除了解控技能,  可能禁止受击<br>沉默BUFF:              禁止所有(部分)技能释放<br>无敌BUFF: 不接受任何伤害<br>霸体BUFF: 打断受击状态并免控<br>灯笼BUFF: 可困住霸体BUFF单位<br>解控技能: 接触被控状态但无法接触部分例如灯笼BUFF<br>净化技能: 移除DEBUFF<br>破盾技能: 移除带有指定盾效果的BUFF<br>致命一击: 突破所有防御包括部分无敌BUFF .<br>引导技能A: 可被强控技能打断<br>引导技能B: 可被移动取消<br>连招技能: 需要前置技能成功释放完成<br>千斤坠技能: 需要飞行状态可释放     </p>
</blockquote>
<p>几乎所有的技能和buff之间都需要定义好他们的交互关系, 包括依赖条件, 禁止状态,  打断逻辑,  替换规则, 触发节奏, 否则在不断的引入新的技能时, 很容易导致已有的系统出现局部甚至整体的错误流程和功能表现.   </p>
<p>而作为一个灵动丰富的多样性的技能系统, 在具体的状态关系上往往不会是简单的禁止打断逻辑, 而是分梯度, 计数, 浮动值的不同而有不同的分支策略, 需要对这样的一个规模和结构复杂的系统进行井井有条的管理和维护, 则需要一套完善灵活的拆分理念和管理机制.   </p>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/2020/06/18/2020-06-18-skill-tag/#more" rel="contents">
              Read more &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://zsummer.github.io/2020/06/18/2020-07-15-gcd/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="夏天">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="关于夏天的一切">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/06/18/2020-07-15-gcd/" itemprop="url">技能系统中的输出循环和节奏控制</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-06-18T00:00:00+08:00">
                2020-06-18
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/develop/" itemprop="url" rel="index">
                    <span itemprop="name">develop</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <h1 id="技能系统中的循环控制"><a href="#技能系统中的循环控制" class="headerlink" title="技能系统中的循环控制"></a>技能系统中的循环控制</h1><h2 id="动作循环控制"><a href="#动作循环控制" class="headerlink" title="动作循环控制"></a>动作循环控制</h2><hr>
<ul>
<li>动作类技能, 普攻等依赖战斗单位身体动作的技能, 其受影响的身体部位不能同时做出两个动作   </li>
<li>根据技能的价值级别以及特色设计, 在可能导致冲突的两个动作之间需要明确打断关系    </li>
</ul>
<h3 id="设计策略"><a href="#设计策略" class="headerlink" title="设计策略"></a>设计策略</h3><p>无论是时间线的设计还是多段设计亦或是朴素的单段多子技能设计,  我们需要标记出每段动作的影响部位, 其意义是在于我们对所有技能通过打标记的形式来获得’技能与技能之间是否存在动作冲突’的信息.     </p>
<p>其次, 我们需要对冲突的技能之间的 重叠释放问题,  这里本质上是一个压制规则问题.   </p>
<ol>
<li>冲突的动作类技能一旦释放成功,  一定打断掉所有相关旧的技能</li>
<li>如果不做上下半身分离, 普通移动视为动作, 否则为下半身动作  </li>
<li>不希望被某些类型打断的时候  要禁止这些类型的技能释放 即压制类标签     </li>
</ol>
<p>举例来说   </p>
<ul>
<li><p>跳击技能:  </p>
<ul>
<li>技能类型:      上半身动作, 下半身动作  </li>
<li>前摇时间压制:  禁止普通移动 禁止下半身动作 禁止上半身动作   </li>
</ul>
</li>
<li><p>出拳技能   </p>
<ul>
<li>技能类型: 上半身动作   </li>
<li>前摇时间压制: 禁止上半身动作  </li>
</ul>
</li>
<li><p>闪避技能   </p>
<ul>
<li>技能类型: 上半身动作 下半身动作   </li>
<li>前摇时间压制: 禁止普通移动 禁止上半身移动 禁止下半身移动    </li>
</ul>
</li>
</ul>
<p>注意:  有些闪避是特色玩法  则需要额外的标签和流程来完成<br>闪避技能进行条件判定时先使用脚本进行预判, 如果当前存在会因动作压制闪避的技能 则先进行打断, 防止被压制<br>所有动作类技能额外添加是否可被闪避技能打断的标签,  单独完成闪避相关的压制处理.   </p>
<p>设计小结:   本质上动作类循环的控制, 在流程上首先是模拟动作状态机,  其次通过压制策略对状态机的切换策略进行控制    </p>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/2020/06/18/2020-07-15-gcd/#more" rel="contents">
              Read more &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://zsummer.github.io/2020/06/16/2020-06-16-lua-oop/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="夏天">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="关于夏天的一切">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/06/16/2020-06-16-lua-oop/" itemprop="url">游戏(技能)中的脚本设计</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-06-16T00:00:00+08:00">
                2020-06-16
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/develop/" itemprop="url" rel="index">
                    <span itemprop="name">develop</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <h1 id="脚本设计"><a href="#脚本设计" class="headerlink" title="脚本设计"></a>脚本设计</h1><h2 id="前言和需求情景"><a href="#前言和需求情景" class="headerlink" title="前言和需求情景"></a>前言和需求情景</h2><p>每种语言都有自己的惯用思维, 面对领域需求时, 也应该在不同的语言思维环境下寻找解决方案, 而不是生搬硬套另外一种语言的特性, 但是从可计算性的角度上来看, 相同需求的良好解决方案往往具备很强的相似性.  </p>
<p>那么更具体的领域中, 我们说说技能系统的场景:  </p>
<p>技能系统的复杂度偏向问题域, 如果不去约束问题域的规模, 最好的解决方案一定是通过脚本化方式让技能的设计者直接去写设计者期望的战斗逻辑. 但是作为一门通用的语言, 是需要转化为一个简洁的, 低门槛的领域语言.  </p>
<p>这里不讨论如何拆解该系统所面对的问题域, 如何抽象出解决域的模型等, 这部分在之前的技能系统相关的PPT中已经描述过,  这里主要关注的是, 在使用脚本的情况下, 我们如何对脚本这部分进行更具体的设计.   </p>
<ul>
<li>作为开发者, 更关注的是开发测试成本, 即用最简洁的代码, 一劳永逸的提供最丰富的上层接口.   </li>
<li>作为设计者, 更关注的是是否提供了足够的封装, 隐藏掉不需要关心的功能实现细节以及流程细节, 并且能够总是通过简单的if else call来完成所有决策, 或者用简单的枚举或者画图 打钩完成所有决策而不需要操刀脚本编写.  </li>
</ul>
<ul>
<li>更进一步的, 从设计者角度, 按照配置的出场频度和复杂度应该有如下的方案选型排序:<font color=#f33 size=3>   <ul>
<li>几乎总是需要配置的:  默认配置方案,  什么都不需要做就是应该有的功能或者流程   </li>
<li>次高频:  通过开关来切换功能或者流程   </li>
<li>高频: 通过枚举来完成多功能或者多流程case   </li>
<li>高频低中度复杂: 通过枚举+固定的跟随参数来完成   </li>
<li>高频低中度复杂: 开发人员编写特定的功能模块, 条件模块, 并提炼出参数以特定枚举方式提供   </li>
<li></li>
<li>中低频复杂条件: 嵌入简短的脚本, 通过数据接口+脚本提供的布尔表达式来完成   </li>
<li>中低频复杂逻辑: 开发人员协助设计者编写脚本      </li>
<li>中低频中低复杂: 策划自行写脚本 自行验证  </li>
<li>低频其他: 脚本兜底实现  </font>    </li>
</ul>
</li>
</ul>
<ul>
<li><p>对于中小型硬核技能玩法项目  或者设计者本身有一定的编程功底, 那么我们可以实现一个简洁的脚本驱动的内核, 然后任由设计者天马行空的设计和铺展战斗系统.   </p>
</li>
<li></li>
<li><p>但对于另外一些情况, 比如存在大规模的低复杂度技能设计, 或者策划人员对脚本的接受能力参差不齐, 我们需要对脚本的适用范围进行收敛, 但是仍然想要灵活的机制来实现丰富的技能体系.  这就需要对涉及到脚本编写部分的更具体的优化设计.     </p>
<ul>
<li><p><font color=#f33 size=3>直接提高数据驱动部分的配置在整个技能系统下所包含的范围</font>   </p>
<blockquote>
<p>通过堆开发人力来提高.  但是这部分会随着需求的细化和新需求的提出导致不断的重构, 开发人员需要持续跟进<br>持续变更的核心代码会降低整个系统的稳定性, 因此这部分的工作需要克制,谨慎的拆解,分析,以及交付测试.   </p>
</blockquote>
</li>
<li><p><font color=#f33 size=3>把可以简单替换成脚本的逻辑, 给设计者提供数据驱动的配置接口, 在配表完成阶段或者读取配置阶段翻译成脚本</font>   </p>
<blockquote>
<p>相比上面的方案, 该方案不需要修改核心逻辑, 性能略有下降.   </p>
</blockquote>
</li>
<li><p><font color=#f33 size=3>提供脚本片段/脚本模版, 配置时候快速复用已有脚本逻辑</font>   </p>
<blockquote>
<p>相比上面一条, 该方案设计者可见脚本代码, 但是不需要手写.<br>不容易出错, 可以用来熏陶设计者对脚本的接受能力, 降低脚本门槛.   </p>
</blockquote>
</li>
<li><p><font color=#f33 size=3>提供脚本级别的封装机制, 对脚本复杂度进行降级</font>   </p>
<blockquote>
<p>把复杂的脚本实现拆解成独立的多段脚本函数, 一次测试多次复用<br>把多行脚本能完成事情 封装成一行脚本 或者一个函数+参数的形式<br>把简单的脚本映射成数据驱动的枚举+参数形式  (直接映射为封装好的函数+参数)<br>封装的位置单独存放在脚本文件中, 并且支持热更新方便快速试错和验证  </p>
</blockquote>
</li>
</ul>
</li>
</ul>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/2020/06/16/2020-06-16-lua-oop/#more" rel="contents">
              Read more &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://zsummer.github.io/2020/05/09/2020-05-09-memory_alloctor/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="夏天">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="关于夏天的一切">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/05/09/2020-05-09-memory_alloctor/" itemprop="url">内存分配器</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-05-09T00:00:00+08:00">
                2020-05-09
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/develop/" itemprop="url" rel="index">
                    <span itemprop="name">develop</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2><span id="内存分配器核心思想和算法">内存分配器核心思想和算法</span></h2><h3><span id="内存管理策略">内存管理策略</span></h3><h4><span id="sequential-fit-连续适配">Sequential Fit  (连续适配)</span></h4><p> 是基于一个单向或双向链表管理各个blocks的基础算法，因为和blocks的个数有关，性能比较差。这一类算法包括Fast-Fit, First-Fit, Next-Fit, and Worst-Fit。  </p>
<h4><span id="segregated-list-分离列表">Segregated List (分离列表)</span></h4><p> 将所有的空闲块，放入到一组链表中，每一个链表中只包含某一个大小范围的空闲块  </p>
<ul>
<li>Buddy System (Sequential Fit变种)  <ul>
<li>内部碎片化问题比较严重   </li>
<li>Binary Buddies  </li>
<li>Fibonacci Buddies  </li>
<li>Weighted Buddies   </li>
</ul>
</li>
</ul>
<h4><span id="indexed-fit">Indexed  Fit</span></h4><p> 通过一些高阶的数据结构来索引（Index）空闲的内存块。例如基于平衡树的“Best Fit”算法。</p>
<ul>
<li>使用Balanced Tree的Best Fit allocator</li>
<li>使用Cartesian tree 的Stephenson Fast-Fit allocator</li>
<li>Bitmap Fit (Indexed Fit 变种)<br>Indexed Fit算法的变种，通过一小段内存的位图来标记对应的内存是空闲的还是使用中。  </li>
</ul>
<h3><span id="路径匹配策略">路径匹配策略</span></h3><p>对于操作系统而言, 除了管理进程之外, 还需要有效的管理计算机的主内存, 管理主内存的共享使用和最小化内存访问时间是内存管理器的基本目标. 虽然使用了各种不同的策略来为争夺内存的进程分配空间，但最流行的三种策略是最佳匹配、最不适合匹配和首次匹配.    </p>
<ul>
<li>Best fit:<br>The allocator places a process in the smallest block of unallocated memory in which it will fit. For example, suppose a process requests 12KB of memory and the memory manager currently has a list of unallocated blocks of 6KB, 14KB, 19KB, 11KB, and 13KB blocks. The best-fit strategy will allocate 12KB of the 13KB block to the process.<br>最佳匹配:<br>这种匹配策略中, 分配器会从满足匹配要求的未分配内存中选择最小的块.<br>例如程序请求一个12kb的内存, 而当前的内存管理器有一个未分配的内存块列表, 分别为14k, 19k, 11k, 13k, 那么best-fit讲从13k的内存块中分配内存给程序.  </li>
</ul>
<ul>
<li><p>Worst fit:<br>The memory manager places a process in the largest block of unallocated memory available. The idea is that this placement will create the largest hold after the allocations, thus increasing the possibility that, compared to best fit, another process can use the remaining space. Using the same example as above, worst fit will allocate 12KB of the 19KB block to the process, leaving a 7KB block for future use.<br>最不适合匹配<br>内存管理器总是选择获得的最大的那个未分配内存块.<br>这种策略在每次分配后总是持有最大的内存块, 从而增加匹配的可能性. 与最佳匹配相比, 其他的请求可以使用剩余的空间.(最佳匹配的剩余内存往往无法利用)<br>同上例, 最坏匹配会从19k的那个内存块中分配, 并留下7k的内存留给将来使用.  </p>
</li>
<li><p>First fit:<br>There may be many holes in the memory, so the operating system, to reduce the amount of time it spends analyzing the available spaces, begins at the start of primary memory and allocates memory from the first hole it encounters large enough to satisfy the request. Using the same example as above, first fit will allocate 12KB of the 14KB block to the process.<br>通常内存中会存在很多空洞, 所以操作系统为了减少分析可用空间的性能(时间)消耗, 会从主要内存或者 第一个足够大并且满足求要的可分配内存的起始位置相应请求.<br>同上例中, 首先匹配会从14k的block中分配12k的请求.<br>First Fit的一个改良版本叫做Next Fit, 即在下次请求时会从上次中断的地方的开始搜索, 从而避免总是从起始的空闲内存开始查找. (Designated victim), First Fit的策略会倾向于总是把大块切的更零碎也因此带来更多的外部碎片问题, 也因为总是从空闲内存的头部开始切造成更多的内部碎片,  而Next Fit的做法会避免(改良)这些问题, 并且速度比Firt 以及 Best更快.  </p>
</li>
</ul>
<h4><span id="tlsf-a-new-dynamic-memory-allocator-for-real-time-systems">TLSF: a New Dynamic Memory Allocator for Real-Time Systems</span></h4><p>通过一组链表来管理不同大小内存块的内存分配算法。<br>适用环境和要求:<br>内存分配/释放的执行时间可预期，可接受的。由于RTOS对指令的执行时间有严格要求，所以常常采用静态内存分配的方法，以获得一个可以预期的执行时间。<br>内存分配算法的碎片化程度要低，这是由于RTOS往往长时间执行，碎片化程度高会导致内存分配失败。<br>实时系统动态内存算法<br>可信的执行环境，Trusted Environment，应用不会故意破坏数据或者窃取数据。<br>有限的物理内存。<br>没有物理MMU来支持虚拟内存。</p>
<p>核心概念: Two Level<br>基本的Segregated Fit算法是使用一组链表，每个链表只包含特定长度范围来的空闲块的方式来管理空闲块的，这样链表数组的长度可能会很大。如下图，TLSF为了简化查找定位过程，使用了两层链表。第一层，将空闲内存块的大小根据2的幂进行分类，如（16、32、64…）。第二层链表在第一层的基础上，按照一定的间隔，线性分段。比如2的6次方这一段，分为4个小区间【64,80），【80,96），【96,112），【112，128）.每一级的链表都有一个bitmap用于标记对应的链表中是否有内存块。比如第一级别bitmap的后4bit位0100，即2的6次方这个区间有空闲块。对应的第二级链表的bitmap位0010及【80,96）这个区间有空闲块，即下面的89 Byte。</p>
<p>策略:<br>Immediate coalescing，立即合并，当内存块被释放后，立即与相邻的空闲内存块合并，以获得一个更大的空闲块，插入到链表的相应位置。这样可以减少碎片化。<br>Splitting threshold，分割阈值，最小可分配的内存块大小为16字节，应用一般不会分配一些基本的数据结构，如int、char等。限定最小可分配大小为16字节，这样可以在空闲的内存块中存储一些管理信息。<br>Good-fit strategy，TLSF会尽可能的返回一个最小的、能够满足需求的内存块。<br>Same strategy for all block sizes，对于不同大小的内存请求，TLSF只有一个分配策略，实现相对简单，执行时间可以预期。相应的dlmalloc根据所请求的内存大小不同，有多达4种内存分配策略。<br>Memory is not cleaned-up，分配个应用的内存没有被请0.</p>
<p>特点:<br>可以预期的分配执行时间，无论对于多达的内存分配请求，TLSF可以在限定的时间内完成分配。<br>碎片化程度低。</p>
<h4><span id="mimalloc">mimalloc:</span></h4><h4><span id="多线程">多线程</span></h4><ul>
<li>局部化, 本地缓存/链表  </li>
<li>注意false shared  </li>
<li>跨线程队列 最大本地缓存 </li>
</ul>
<h4><span id="内存安全">内存安全</span></h4><p>管理数据和被管理内存分离<br>buddy system<br>pages 管理  </p>
<p>可信的执行环境Trusted Environment，应用不会故意破坏数据或者窃取数据<br>有限的物理内存<br>有限的物理地址<br>没有物理MMU来支持虚拟内存</p>
<h4><span id="开源内存分配器">开源内存分配器</span></h4><ul>
<li>dlmalloc </li>
<li>tcmalloc  </li>
<li>jemalloc  </li>
<li>Hoard</li>
<li>minimalloc</li>
<li>TLSF: <a href="https://github.com/OlegHahm/tlsf" target="_blank" rel="noopener">https://github.com/OlegHahm/tlsf</a>    </li>
</ul>
<h4><span id="援引">援引</span></h4><p><a href="https://github.com/everschen/tools/blob/master/DOC/Jemalloc.pdf" target="_blank" rel="noopener">jemalloc深入分析 PDF</a><br><a href="http://applicative.acm.org/2015/applicative.acm.org/speaker-JasonEvans.html" target="_blank" rel="noopener">jemalloc 2015演讲视频 tick tock, malloc needs a clock 背景和初始设计思想介绍</a><br><a href="https://www.facebook.com/notes/facebook-engineering/scalable-memory-allocation-using-jemalloc/480222803919" target="_blank" rel="noopener">jemalloc facebook工程贴</a><br><a href="http://people.freebsd.org/~jasone/jemalloc/bsdcan2006/jemalloc.pdf" target="_blank" rel="noopener">BSDcan paper 2006</a><br><a href="https://dl.acm.org/doi/abs/10.1145/3329785.3329918" target="_blank" rel="noopener">On the Impact of Memory Allocationon High-Performance Query Processing</a><br><a href="https://www.jamesgolick.com/2013/5/19/how-tcmalloc-works.html" target="_blank" rel="noopener">How tcmalloc Works</a><br><a href="https://www.chromium.org/chromium-os/chromiumos-design-docs/out-of-memory-handling" target="_blank" rel="noopener">Chromimum Project: Out of memory handling</a><br><a href="https://rd.springer.com/content/pdf/10.1007%2F978-1-4842-4398-5_7.pdf" target="_blank" rel="noopener">Scalable Memory Allocation TBB</a><br><a href="https://cloud.tencent.com/developer/article/1173720" target="_blank" rel="noopener">ptmalloc,tcmalloc和jemalloc内存分配策略研究</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://zsummer.github.io/2020/05/09/2020-06-15-shadowsock-proxy/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="夏天">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="关于夏天的一切">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/05/09/2020-06-15-shadowsock-proxy/" itemprop="url">shadowsocks代理远端和本地配置以及VPS上的bbr开启等</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-05-09T00:00:00+08:00">
                2020-05-09
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/develop/" itemprop="url" rel="index">
                    <span itemprop="name">develop</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <h2 id="shadowsocks服务器配置"><a href="#shadowsocks服务器配置" class="headerlink" title="shadowsocks服务器配置"></a>shadowsocks服务器配置</h2><ul>
<li><p>安装shadowsocks  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-get install shadowsocks</span><br></pre></td></tr></table></figure></li>
<li><p>配置shadowsocks<br>配置路径</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;etc&#x2F;shadowsocks&#x2F;config.json</span><br></pre></td></tr></table></figure></li>
<li><p>配置内容(参考):</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;server&quot;:[&quot;::1&quot;, &quot;0.0.0.0&quot;],</span><br><span class="line">  &quot;mode&quot;:&quot;tcp_and_udp&quot;,</span><br><span class="line">  &quot;server_port&quot;:8080,</span><br><span class="line">  &quot;password&quot;:&quot;****&quot;,</span><br><span class="line">  &quot;method&quot;:&quot;aes-256-cfb&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/2020/05/09/2020-06-15-shadowsock-proxy/#more" rel="contents">
              Read more &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://zsummer.github.io/2020/02/07/2020-02-03-shared-memory-resume-overview/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="夏天">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="关于夏天的一切">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/02/07/2020-02-03-shared-memory-resume-overview/" itemprop="url">基于共享内存的对象池管理方案</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-02-07T00:00:00+08:00">
                2020-02-07
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/develop/" itemprop="url" rel="index">
                    <span itemprop="name">develop</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <h3 id="1-目录"><a href="#1-目录" class="headerlink" title="..1. 目录"></a>..1. 目录</h3><h3 id="通用的对象池方案"><a href="#通用的对象池方案" class="headerlink" title="通用的对象池方案"></a>通用的对象池方案</h3><p>该方案本质上一个简单分离存储的内存分配方案:<br>分配器维护多个空闲链表, 每个空闲链表包含大小相等的空闲块 每个块的大小为这个大小类中最大元素的大小, 不分割不合并.    </p>
<p><img src="/images/objpools.png" alt="buddy_system">  </p>
<h4 id="数据结构定义"><a href="#数据结构定义" class="headerlink" title="数据结构定义"></a>数据结构定义</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">对象池管理器</span><br><span class="line">  [对象A条目IDX]: 对象是否包含虚函数(是否需要重建虚函数表):  对象类型(对应条目IDX): 对象大小: 对象个数: 该条目总长: 条目对应内存地址:  条目对应对象起始地址: 空闲对象下标ID : 已分配计数   </span><br><span class="line">  [对象B条目IDX]: 对象是否包含虚函数(是否需要重建虚函数表):  对象类型(对应条目IDX): 对象大小: 对象个数: 该条目总长: 条目对应内存地址:  条目对应对象起始地址: 空闲对象下标ID : 已分配计数   </span><br><span class="line">  [对象C条目IDX]: 对象是否包含虚函数(是否需要重建虚函数表):  对象类型(对应条目IDX): 对象大小: 对象个数: 该条目总长: 条目对应内存地址:  条目对应对象起始地址: 空闲对象下标ID : 已分配计数   </span><br><span class="line">  [对象D条目IDX]: 对象是否包含虚函数(是否需要重建虚函数表):  对象类型(对应条目IDX): 对象大小: 对象个数: 该条目总长: 条目对应内存地址:  条目对应对象起始地址: 空闲对象下标ID : 已分配计数</span><br></pre></td></tr></table></figure>

<p>单个条目指向的起始地址结构:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flag|flag|flag : ...  FENCE SIZE: NODE SIZE :   FENCE SIZE: NODE SIZE :   ...</span><br></pre></td></tr></table></figure>
<p>条目指向的地址会首先保存flag标志标明该对象是否在使用中, 用于请求和释放时候的判定标志<br>NODE SIZE会进行8字节对齐, FENCE SIZE也选择8字节 这样整个对象池的地址都是保证8字节对齐的<br>FENCE写入特殊固定的魔法数值 用于溢出检测<br>分配出去的对象 NODE SIZE的起始地址即为对象的地址<br>空闲的对象, 其NODE SIZE的第一个U32保存的是下一个空闲内存 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">: NODE SIZE: 对应下面结构</span><br><span class="line">: FREE IDX, NODE SIZE- FENCE SIZE:</span><br></pre></td></tr></table></figure>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/2020/02/07/2020-02-03-shared-memory-resume-overview/#more" rel="contents">
              Read more &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://zsummer.github.io/2020/02/07/2020-02-07-shared-memory-buddy_system/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="夏天">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="关于夏天的一切">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/02/07/2020-02-07-shared-memory-buddy_system/" itemprop="url">基于共享内存的通用内存分配器</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-02-07T00:00:00+08:00">
                2020-02-07
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/develop/" itemprop="url" rel="index">
                    <span itemprop="name">develop</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3><span id="1-目录">..1. 目录</span></h3><h3><span id="linux系统的内存管理设计">linux系统的内存管理设计</span></h3><p><img src="/images/system_memory.jpg" alt="buddy_system"><br>Linux内核内存管理的一项重要工作就是如何在长期频繁申请释放内存的情况下, 避免碎片的产生.<br>Linux采用伙伴系统在极高的分配和回收性能(LGN)上, 最大化的减少了外部碎片(总是合并伙伴内存)的产生.<br>伙伴算法非常简洁并且容易实现, 其一般实现的核心思路为维护一个整块内存, 通过不断的2分把最适配的内存分配给用户, 并且总是优先选择最零碎的空闲内存进行适配, 在回收时候则总是会合并空闲的伙伴内存(左右两个子节点的关系称之为伙伴关系), 以此来尽可能的保证大块的连续内存.<br>但是伙伴算法要求分配的内存必须是2的幂次大小, 因此直接使用会带来大量的内部碎片, 也因此伙伴算法一般都是作为底层内存管理算法不直接提供给用户, 而是通过dlmalloc等slab算法或者衍生算法提供给最终用户.  </p>
<p>linux采用slab算法来进行更细粒度的内存分配管理, 通过分箱算法, 对于小内存(256字节及以下, 分离存储)可以达到常数的性能, 对于 &gt;256 &amp;&amp; &lt;1m的内存可以做到不大于LGN的分配性能, 并且通过对大块内存的精细切分和分箱算法可以做到几乎没有内部碎片, 通过对空闲内存的合并(没有伙伴关系约束也不存在假碎片问题, 但是因为大小chunk混合切分带来了更多的合并次数) 也有效的控制了外部碎片的产生.  </p>
<p>linux面对的环境在通用性上要求更高, 考虑到brk/mmap作为系统调用在一些环境下的性能差异表现, 以及小内存的在初始化数据(查找 切分等), slab相关的算法中更倾向于缓存足够多的block来保证小内存在分配上的性能表现, 而操作系统heap苛刻的收缩条件也会导致在项目中的实际表现往往是整个heap的内存总是接近保持在峰值水平上, 换句话说slab算法在实际的实现中其分配策略更接近’内存池’的概念.  </p>
<p>其分箱算法采用64位的bitmap 也就是64个箱位, 支持单个内存分配请求的大小范围在dlmalloc的实现中为8字节-1M, 又因为内存池的分配策略, 以及外部碎片的有限控制, 所以slab只是一个针对小内存分配优化方案, 对于一个通用分配器来说仍然需要大内存的分配方案.   </p>
<p>因此包括linux内核, 整体的通用内存分配方案中, 使用buddy算法或者衍生算法来做大块线性地址空间的管理, 保证性能的情况下最小化外部碎片的产生, 通过slab算法或者衍生算法维护一个小内存请求的内存池, 以增加一小部分外部碎片的代价换取更少的内部碎片产生, 并保证向buddy system索要的内存都是满足2的幂次大小,  从而得到一个综合性能最优的方案, 这个方案比喻成[buddy算法负责批发 slab算法负责零售]具有比较形象的参考价值.    </p>
<h3><span id="伙伴算法">伙伴算法</span></h3><p>因为最终的目的是希望把伙伴算法的管理结构保存在共享内存中,  因此我们在数组结构上以完美二叉树(perfect binary tree)的方式构建了整个伙伴算法,  由于对cpu cache友好的特征, 并且全局几乎只有简单的加减位移操作, 所以整个实现可以在非常简洁的基础上得到了一个比较出色的性能表现.   </p>
<h4><span id="数据结构和概述">数据结构和概述</span></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  perfect binary tree</span></span><br><span class="line"><span class="comment">*                   0        -----------   : reserve</span></span><br><span class="line"><span class="comment">*	                  1        -----------   :  root </span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*          2                 3</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*     4        5         6        7</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*   8   9   10   11   12   13  14   15</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* ----------------------------------------</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*   0   1   2    3    4    5   6     7     : memory buff</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p><img src="/images/buddy_system.gif" alt="buddy_system"><br>伙伴算法是一个特殊的分离适配的内存管理器  </p>
<ul>
<li><p>能被有效管理的内存大小必须是2的幂次方   </p>
</li>
<li><p>分配的内存大小一定是2的幂次大小对齐, 通过逐层向下2分找到最适配请求的大小  </p>
</li>
<li><p>回收的内存会逐层向上合并 并且总是幂次大小合并 并且只能对伙伴内存(左右子节点)进行合并     </p>
</li>
<li><p>显而易见的内部碎片<br>因为2的幂次对齐分配, 比如我们需要power(2, 12)+1 的内存 实际上就会分配power(2,13)的内存,  内部碎片比例为 (power(2, 12)+1)/power(2,13), 有效负荷只有0.5左右.<br>伙伴系统的分配粒度如果为页框机制, 例如采取页框大小为4k(方便匹配操作系统的页大小), 那么即使请求1个字节也需要一个完整的页框内存,  有效负荷只有1/(4k-1)即4k分之一.  </p>
</li>
<li><p>显而易见的假碎片<br>两块相邻的空闲内存因为不属于伙伴关系则无法合并, 换句话说存在一块连续的空闲地址满足需求但是却因为无法在内存管理器中完成合并操作而不能提供服务.<br>比如上面结构中 IDX 9 和 IDX 10皆为空闲,  IDX 9 和 IDX 5皆为空闲等      </p>
</li>
<li><p>存在但被有效控制的外部碎片<br>对于动态内存分配策略中, 只要满足通用性目标中”处理任意请求序列” 那么就一定会有外部碎片的产生, 因为其产生不仅仅在于分配器管理结构的设计, 更在于将来时, 外部的请求和释放时机.<br>  如图所示中, 我们并不能保证不会出现索引11和12被分配出去其他内存全部空闲这样的情况, 导致总空闲内存大小为6但是只能最大分配3个连续页框 .<br>但相比其他的分配方案, 合并成一个2倍大小的大块内存, 总是只需要两个空闲小块, 而在分配策略中又总是会分配大小相同且相邻的块, 可以说是所有分配策略在保证LGN性能下控制外部碎片最好的方案.  </p>
</li>
</ul>
<ul>
<li>较为恒定的分配复杂度<br>分配时会从根节点向下查找直到适配, 回收时从叶子节点向上查找, 并且都会从对应节点向根节点方向进行分配能力的修改.<br>因此一对分配和释放请求总是恒定为LGN  </li>
</ul>
<h4><span id="数据结构的定义">数据结构的定义:</span></h4><p>同linux系统的方式类似, 我们按照页框为单位来管理内存, 页框的大小大于等于系统的页框大小, 可结合slab分配器进行调整.<br>根据要管理的内存大小和页框大小, 我们可以算出总得叶子数量,  而在这棵树上, 节点总数为2N(2倍叶子节点)   </p>
<p>因此数据结构的定义为如下方式:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">共享内存管理头部: 所有叶子节点 : 被管理的内存</span><br></pre></td></tr></table></figure>

<p>每个节点用1个字节来记录, 内容为该节点的所对应的空间大小, (这里记录的不是大小, 而是大小的幂, 所以可以用一个字节来存储)<br>该节点对应的空间起始地址这位该节点在该层中的<code>offset* power(2, order)</code></p>
<h5><span id="初始化">初始化</span></h5><p>所有节点的初始化为为该节点的空间大小.<br>例如index1 对应的则是被管理的所有空间<br>然后每层递减1<br>到叶子节点则为2^0次幂大小, 即一个页框单位.  </p>
<h5><span id="分配">分配</span></h5><p>如果分配参数是字节数, 则需要先按照页框向上取整<br>如果分配的参数是页框数量, 则需要按照2的幂次取整, 可以用bit search指令获取2的幂数(这个取法是向下取整 所以取完后要进行一次向上取整)<br>如果分配的是order<br>则检查root节点保存的order是否满足需求, 不满足这代表没有足够大的空间<br>如果满足需求则逐层查找, 直到到达对应的order层级, 然后修改该节点的可分配空间为0, 然后逐层向上修改分配能力  </p>
<p>tips:<br> 这里定义0为已分配, 而不是power(2,0)个空间大小,  因此在这里节点对应空间大小计算是power(2, (order ability)-1)   -1后才是power(2, order) .<br> 这样可以保证这棵树中从叶子节点向上查找时候的可以简单的while循环时候少一次边界判定, 计算方便   </p>
<p>分配时候永远选择刚好满足需求的路径, 可以减少切分大块, 其次优先左子树,  减少外部碎片的产生以及提高cache命中.  </p>
<h5><span id="释放">释放</span></h5><p> 通过地址计算页框编号, 然后加上N (树的大小是2N, N为所有非叶子节点的节点总数) 得到叶子节点的索引.<br> 从叶子节点用IDX /2 不断的向上查找, 直到找到节点被标记为0的层级,  修改该节点为该层级对应的空间大小, 然后逐层向上修改每层的新的空间分配能力, 如果左右节点的空间大小为该层级的大小(都空闲)则合并,(每个上层节点的能力均是节点对应的空间大小)   </p>
<h3><span id="slab内存分配器">SLAB内存分配器</span></h3><p>有了buddy system之后, 移植所有可以基于mmap或者brk批量分配的内存分配器都会变得容易, 常见的现在linux系统使用的ptmalloc属于dlmalloc的分支版本, 而常用的TCMALLOC或者jemalloc都是基于dlmalloc的思想进行了更优更细粒度的实现, 体现在cpu cache更友好的分配策略以及多线程下更少的竞争等来获取更好的分配性能.      </p>
<p>dlmalloc有着更简洁干净的实现 大约只有5000行代码, 其设计也非常的出色, 可以说是最容易移植的优秀的内存分配器.  </p>
<h4><span id="基础术语和概念如下">基础术语和概念如下:</span></h4><p>Payload: 有效负载.指的是实际交给应用程序使用的内存大小.  </p>
<p>Overhead: 负载,开销.本意是为了满足分配需求所消耗的内存量,实际在代码注释中多指除了payload之外的额外开销(有些书中也称之为cookie).  </p>
<p>Chunk: 区块.是内存分配的基本单位,类似物质世界中的原子不可再分. dlmalloc对内存的管理基本上都是以chunk为单位.一个典型的chunk是由用户程序使用的部分(payload)以及额外的标记信息(overhead)组成.  </p>
<p>Bin: 分箱.用来管理相同或同一区间大小的chunk.在dlmalloc中分为sbin和tbin两种.  </p>
<p>Mspace: 分配空间.说白了就是dlmalloc中内存池的叫法.在dlmalloc中可以管理多个mspace.如果不显式声明,将会使用一个全局的匿名空间,或者用户可以自行划分空间交给dlmalloc管理.  </p>
<p>Segment: 区段.一般情况下,内存分配都是在一片连续区间内开采(exploit).但也会遇到不连续的情况,这就需要分成若干个区段记录.多个区段可以同属一个mspace.  </p>
<p>Fenceposts: 栅栏.大多数分配器中, fencepost起到非连续内存间的隔离作用.一般这种隔离被用做安全检查.分配器会在fenceposts所在位置写上特殊标记,一旦非连续内存间发生写入溢出(overwrite)就可以通过异常的fenceposts值发出警告.  </p>
<p>Bookkeeping: 记录信息.不同于每个chunk中的overhead,这里指的是整个mspace控制块的记录信息.往往这部分信息都固定在mspace开始的一段空间,或者干脆就放在地址空间的静态区中.  </p>
<p>Granularity: 粒度.这个粒度指的是从system heap上获取内存的最小单位.一般来说该值至少为一个page size, 且必须以2为底.  </p>
<p>Mmap: 本意是类unix系统的文件映射调用.但在dlmalloc中表示的更宽泛,这里指代可以在进程地址空间中开辟非连续内存空间的系统调用.  </p>
<p>Morecore: 指可以在进程地址空间中开辟连续内存空间的系统调用.在类unix系统下morecore指的是sbrk调用.  </p>
<p>Program break: 前面提到的sbrk()实际也是一个库函数,真正起作用的是brk()系统调用.这个函数其实就是break的缩写.所谓的break是一个代表进程heap区top-most位置的指针.当我们通过sbrk/brk向系统请求内存时,系统做的仅仅是移动break指针,内存就这样被划拨到heap中了.而当释放内存时,就反方向移动该指针,内存就返回给系统.  </p>
<p>Footprint: 从系统获得的内存量.指的是当前dlmalloc从system heap获取的内存总和.设立footprint一方面是为了方便统计,另一方面也可以限制dlmalloc从系统获取的最大内存量.   </p>
<p>Trimming: 裁剪.被dlmalloc管理的内存被free后,并不直接返还给系统,而是当积累到一定程度会通过一些算法判断system heap是否收缩(shrink),这个过程在dlmalloc中称作auto-trimming.   </p>
<h4><span id="分箱机制">分箱机制</span></h4><p>分箱指的是在内存分配器内部划定一些chunk集合, 每个集合中记录的都是固定大小或区间的free chunk, 当分配时可以直接从中找到最贴近用户要求的那一个.<br>越是想要高效的分配,就越要将分箱划分的更细致,相应的也就浪费更多的内存, 因此, 分箱机制既不能太粗放而影响效率, 也不能太细致而降低利用率.<br>分箱算法通过位移的计算技巧, 可以简单且快速的找到满足请求大小的最小非空箱位索引</p>
<h4><span id="小内存分配">小内存分配</span></h4><p>dlmalloc定义了最小的分配粒度为8字节, 这样在保存chunk大小的字段中可以多出来3个位作为bit标记<br>然后每8个字节递增, 直到248字节, 总共32个箱子 如下:   </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[bin idx] 8 8 8 8 8 8 8 8 8 </span><br><span class="line">[bin idx] 16 16 16 16 16 16   </span><br><span class="line">[bin idx] 24 24 24 24 24 24   </span><br><span class="line">...</span><br><span class="line">[bin idx] 248 248 248 248 248 248</span><br></pre></td></tr></table></figure>

<p>在64位下需要保证分配给用户的地址是两倍(void*)大小且包含一个8字节的prev_foot 一个8字节的head, 因此实际上使用的箱位不会用满32个.<br>dlmalloc的prev_foot是一个边界标记法的使用技巧, 逻辑上其实是上一个chunk的foot部分, 如果不是空闲状态则会标记”下个chunk的P”为非空闲,  如果是空闲则会填充该字段为空闲chunk的大小.<br>这样就可以完成一个块从分配状态到空闲状态时候 总是能直接向前合并或者向后合并.<br>在非空闲状态没有合并需求, 因此为了充分利用内存, 分配状态的chunk其foot部分总是被’踩’的,  也就是说这里的的箱位使用在实际情况下(64位)<br>是32byte开始, 后面以24字节递增(踩prev_foot) 48byte 64byte 直到240byte  对于调用dlmalloc接口请求的大小在超过232字节后就会走big bin分配[256~384)范围的内存.   </p>
<p>分配:  </p>
<p>首先检查对应bin idx是否有空闲chunk 有这分配并返回<br>其次检查更高bin idx中是否有空闲的chunk, 有则切割, 并把剩余大小组合成一个新chunk记录为切割剩余chunk(如果过小则直接丢给用户)<br>其次检查大内存的bin里面是否有内存 有则切割 同上<br>其次检查上次剩余切割的chunk是否满足需要 如果满足则进一步切割 同上<br>其次检查最新从上级分配器(buddy system, 或者对应系统函数mmap brk)得到的大块chunk的剩余是否满足 满足就切割 (brk表现为扩展top)<br>其次则申请一个新的大块chunk进行切割   </p>
<h4><span id="大内存分配">大内存分配</span></h4><p>大内存的bin idx递增则为2的幂次的半高为区分 总共32个箱子, 箱内是一个特殊实现的bitwise trie tree 如:  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[bin idx] [256~384)  </span><br><span class="line">[bin idx] [384~512)  </span><br><span class="line">[bin idx] [512~768)  </span><br><span class="line">[bin idx] ...  </span><br><span class="line">[bin idx] [4096~6144)  </span><br><span class="line">[bin idx] ...   </span><br><span class="line">[bin idx] [768k~1m)</span><br></pre></td></tr></table></figure>

<p>分配:<br>首先查找对应的bin idx是否存在空闲, 如果空闲则从该bitwise trie tree中查找最佳的chunk节点   </p>
<p>如果当前bin无空闲内存或者没找到合适空闲内存, 则检查更高bin idx中是否存在空闲, 如果有则拿最小的一个chunk </p>
<p>如果找到则切分保存剩余内存为剩余chunk并返回合适大小的内存给用户  </p>
<p>其次检查剩余chunk的大小是否满足, 满足则进一步切割  </p>
<p>其次检查最近一次向上层管理器申请的内存chunk是否满足需求, 满足则切分     </p>
<p>其次选择向底层(操作系统)申请满足需求的大块内存 </p>
<h5><span id="bitwise-trie-tree">bitwise trie tree</span></h5><p>大内存的箱内管理是一个特殊的前缀树, 节点均为0或者1, 和buddy system的结构稍微有点相似 都是做地址空间管理.<br>这个树的的节点是按照chunk的大小(chunk大小在二进制上的0,1顺序作为排序依据)进行构建的<br>并且其节点本身就是chunk,  因此查找时候时候不但要检测叶子节点的大小是否最佳 也要检测其节点路径的chunk大小是否是最佳.<br>添加节点时候会自顶向下查找最佳位置, 如果已经存在大小相同的节点或者叶子节点 则以链表形式附加到该节点的空闲链表中, 如果不存在则直接以叶子节点添加<br>删除(最佳)节点时, 如果该节点有相同大小的其他chunk 则直接替换为相同大小的即可, 如果是叶子节点直接摘除, 否则会从右侧叶子节点提升到该节点位置.   </p>
<p>这棵树的优点是动态树高, 查找的最坏性能是地址空间的LGN复杂度, 在树不满的情况则是相对树高的LGN复杂度,  在插入和删除时只是简单的查找+一次替换/添加操作, 不会对树进行调整, 因此性能非常好.    </p>
<h4><span id="内存回收和内存收缩">内存回收和内存收缩</span></h4><p>回收内存时会根据标志检查是否存在前一个空闲块 如果存在则合并.<br>如果是直接mmap的内存 则直接返还给底层分配器<br>检查是否满足收缩条件, 满足收缩条件则向系统/底层分配器返还内存 这里分heap的堆顶收缩检测和非连续mmap segment回收检测<br>未被返还给底层分配器则插入到对应的bin空闲块中.   </p>
<h4><span id="默认内存分配阈值">默认内存分配阈值</span></h4><p>分配对齐至少8字节 默认为两倍<code>sizeof(void*)</code><br>向系统的索要内存的最小粒度默认为64k, windows下通过api获取到的分配粒度默认也是64k (最小单位)<br>当dlmalloc的请求内存超过阈值256k时 直接向系统索要内存<br>系统的内存分配方式是brk时至少在堆顶缓存一个分配粒度的空闲内存而不是收缩堆顶所有空闲内存<br>系统的内存分配方式是mmap时会通过满足条件一定次数后扫描线性扫描所有segment列表, 对未使用并且完全空闲的segment进行清除(保留堆顶 剩余切分被占用的segment).</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/2/">&lt;i class&#x3D;&quot;fa fa-angle-right&quot;&gt;&lt;&#x2F;i&gt;</a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.png"
               alt="夏天" />
          <p class="site-author-name" itemprop="name">夏天</p>
           
              <p class="site-description motion-element" itemprop="description"></p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives/">
                <span class="site-state-item-count">40</span>
                <span class="site-state-item-name">posts</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              
                <span class="site-state-item-count">1</span>
                <span class="site-state-item-name">categories</span>
              
            </div>
          

          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">夏天</span>
</div>


<div class="powered-by">
  Powered by <a class="theme-link" href="https://hexo.io" target="_blank" rel="noopener">Hexo</a>
</div>

<div class="theme-info">
  Theme -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next" target="_blank" rel="noopener">
    NexT.Gemini
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.2"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.2"></script>



  
    <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.2"></script>

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.2"></script>



  


  




	





  





  






  





  

  

  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script><!-- hexo-inject:begin --><!-- Begin: Injected MathJax -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config("");
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>

<script type="text/javascript" src="custom_mathjax_source">
</script>
<!-- End: Injected MathJax -->
<!-- hexo-inject:end -->
  


  

  

</body>
</html>
